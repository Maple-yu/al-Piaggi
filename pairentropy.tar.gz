src/0000777000175000017500000000000014000310260010611 5ustar  maplemaplesrc/colvar/0000777000175000017500000000000013777445145012136 5ustar  maplemaplesrc/colvar/PairEntropy.cpp0000777000175000017500000005330114000306207015072 0ustar  maplemaple/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   Copyright (c) 2011-2016 The plumed team
   (see the PEOPLE file at the root of the distribution for a list of names)
   See http://www.plumed.org for more information.
   This file is part of plumed, version 2.
   plumed is free software: you can redistribute it and/or modify
   it under the terms of the GNU Lesser General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.
   plumed is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU Lesser General Public License for more details.
   You should have received a copy of the GNU Lesser General Public License
   along with plumed.  If not, see <http://www.gnu.org/licenses/>.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
#include "Colvar.h"
#include "ActionRegister.h"
#include "tools/NeighborListParallel.h"
#include "tools/Communicator.h"
#include "tools/Tools.h"
#include "tools/IFile.h"
#include "math.h"

#include <string>

using namespace std;

namespace PLMD{
namespace colvar{

//+PLUMEDOC COLVAR PAIRENTROPY
/*
Calculate the global pair entropy using the expression:
\f[
s=-2\pi\rho k_B \int\limits_0^{r_{\mathrm{max}}} \left [ g(r) \ln g(r) - g(r) + 1 \right ] r^2 dr .
\f]
where \f$ g(r) $\f is the pair distribution function and \f$ r_{\mathrm{max}} $\f is a cutoff in the integration (MAXR).
For the integration the interval from 0 to  \f$ r_{\mathrm{max}} $\f is partitioned in NHIST equal intervals. 
To make the calculation of \f$ g(r) $\f differentiable, the following function is used:
\f[
g(r) = \frac{1}{4 \pi \rho r^2} \sum\limits_{j} \frac{1}{\sqrt{2 \pi \sigma^2}} e^{-(r-r_{ij})^2/(2\sigma^2)} ,
\f]
where \f$ \rho $\f is the density and \f$ sigma $\f is a broadening parameter (SIGMA).  
\par Example)
The following input tells plumed to calculate the pair entropy of atoms 1-250 with themselves.
\verbatim
PAIRENTROPY ...
 LABEL=s2
 ATOMS=1-250
 MAXR=0.65
 SIGMA=0.01
 NLIST
 NL_CUTOFF=0.75
 NL_STRIDE=10
... PAIRENTROPY
\endverbatim
*/
//+ENDPLUMEDOC

class PairEntropy : public Colvar {
  bool pbc, serial;
  // Neighbor list stuff
  bool doneigh;
  NeighborListParallel *nl;
  vector<AtomNumber> atoms_lista;
  bool invalidateList;
  bool firsttime;
  // Others
  double maxr, sigma;
  unsigned nhist;
  double rcut2;
  double sqrt2piSigma, sigmaSqr2, sigmaSqr;
  double deltar;
  unsigned deltaBin;
  double density_given;
  std::vector<double> vectorX, vectorX2;
  // Integration routines
  double integrate(vector<double> integrand, double delta)const;
  Vector integrate(vector<Vector> integrand, double delta)const;
  Tensor integrate(vector<Tensor> integrand, double delta)const;
  // Kernel to calculate g(r)
  double kernel(double distance, double invNormKernel, double&der)const;
  // Output gofr and integrand
  bool doOutputGofr;
  bool doOutputIntegrand;
  unsigned outputStride;
  void outputGofr(vector<double> gofr);
  void outputIntegrand(vector<double> integrand);
  mutable PLMD::OFile gofrOfile, integrandOfile;
  // Reference g(r)
  bool doReferenceGofr;
  bool noPrefactor;
  std::vector<double> referenceGofr;
  // Average g(r)
  bool doAverageGofr;
  vector<double> avgGofr;
  unsigned iteration;
  // Low communication variant
  bool doLowComm;
public:
  explicit PairEntropy(const ActionOptions&);
  ~PairEntropy();
  virtual void calculate();
  virtual void prepare();
  static void registerKeywords( Keywords& keys );
};

PLUMED_REGISTER_ACTION(PairEntropy,"PAIRENTROPY")

void PairEntropy::registerKeywords( Keywords& keys ){
  Colvar::registerKeywords(keys);
  keys.addFlag("SERIAL",false,"Perform the calculation in serial - for debug purpose");
  keys.addFlag("NLIST",false,"Use a neighbour list to speed up the calculation");
  keys.addFlag("OUTPUT_GOFR",false,"Output g(r)");
  keys.addFlag("OUTPUT_INTEGRAND",false,"Output integrand");
  keys.add("optional","OUTPUT_STRIDE","The frequency with which the output is written to files");
  keys.addFlag("AVERAGE_GOFR",false,"Average g(r) over time");
  keys.addFlag("NO_PREFACTOR",false,"Do not include the prefactor -4*pi*density");
  keys.add("optional","NL_CUTOFF","The cutoff for the neighbor list");
  keys.add("optional","NL_STRIDE","The frequency with which we are updating the atoms in the neighbour list. If non specified or negative, it checks every step and rebuilds as needed.");
  keys.add("optional","DENSITY","Density to normalize the g(r). If not specified, N/V is used");
  keys.add("atoms","ATOMS","List of atoms");
  keys.add("compulsory","MAXR","1.","Maximum distance for the radial distribution function ");
  keys.add("optional","NHIST","Number of bins in the rdf ");
  keys.add("compulsory","SIGMA","0.01","Width of gaussians ");
  keys.add("optional","REFERENCE_GOFR_FNAME","the name of the file with the reference g(r)");
  keys.addFlag("LOW_COMM",false,"Use an algorithm with less communication between processors");
}

PairEntropy::PairEntropy(const ActionOptions&ao):
PLUMED_COLVAR_INIT(ao),
pbc(true),
serial(false),
invalidateList(true),
firsttime(true)
{

  parseFlag("SERIAL",serial);

  parseAtomList("ATOMS",atoms_lista);

  log.printf("  using periodic boundary conditions\n");

// neighbor list stuff
  doneigh=false;
  bool nl_full_list=false;
  double nl_cut=0.0;
  double nl_skin;
  int nl_st=-1;
  parseFlag("NLIST",doneigh);
  if(doneigh){
   parse("NL_CUTOFF",nl_cut);
   if(nl_cut<=0.0) error("NL_CUTOFF should be explicitly specified and positive");
   parse("NL_STRIDE",nl_st);
  }

  density_given = -1;
  parse("DENSITY",density_given);
  if (density_given>0) log.printf("  The g(r) will be normalized with a density %f . \n", density_given);
  else log.printf("  The g(r) will be normalized with a density N/V . \n");

  addValueWithDerivatives(); setNotPeriodic();

  parse("MAXR",maxr);
  log.printf("  Integration in the interval from 0. to %f \n", maxr );
  parse("SIGMA",sigma);
  log.printf("  The pair distribution function is calculated with a Gaussian kernel with deviation %f \n", sigma);
  double rcut = maxr + 3*sigma;
  rcut2 = (maxr + 3*sigma)*(maxr + 3*sigma);  // 3*sigma is hard coded
  if(doneigh){
    if(nl_cut<rcut) error("NL_CUTOFF should be larger than MAXR + 3*SIGMA");
    nl_skin=nl_cut-(maxr+2*sigma);
  }
  nhist=ceil(maxr/sigma) + 1; // Default value
  parse("NHIST",nhist);
  log.printf("  The interval is partitioned in %u equal parts and the integration is perfromed with the trapezoid rule. \n", nhist );
 
  doOutputGofr=false;
  parseFlag("OUTPUT_GOFR",doOutputGofr);
  if (doOutputGofr) { 
     log.printf("  The g(r) will be written to a file \n.");
     gofrOfile.link(*this);
     gofrOfile.open("gofr.txt");
  }
  doOutputIntegrand=false;
  parseFlag("OUTPUT_INTEGRAND",doOutputIntegrand);
  if (doOutputIntegrand) {
     log.printf("  The integrand will be written to a file \n.");
     integrandOfile.link(*this);
     integrandOfile.open("integrand.txt");
  }
  outputStride=1;
  parse("OUTPUT_STRIDE",outputStride);
  if (outputStride!=1 && !doOutputGofr && !doOutputIntegrand) error("Cannot specify OUTPUT_STRIDE if OUTPUT_GOFR or OUTPUT_INTEGRAND not used");
  if (outputStride<1) error("The output stride specified with OUTPUT_STRIDE must be greater than or equal to one.");
  if (outputStride>1) log.printf("  The output stride to write g(r) or the integrand is %d \n", outputStride);

  doReferenceGofr=false;
  std::string referenceGofrFileName;
  parse("REFERENCE_GOFR_FNAME",referenceGofrFileName); 
  if (!referenceGofrFileName.empty() ) {
    log.printf("  Reading a reference g(r) from the file %s . \n", referenceGofrFileName.c_str() );
    doReferenceGofr=true;
    IFile ifile; 
    ifile.link(*this);
    ifile.open(referenceGofrFileName);
    referenceGofr.resize(nhist);
    for(unsigned int i=0;i<nhist;i++) {
       double tmp_r;
       ifile.scanField("r",tmp_r).scanField("gofr",referenceGofr[i]).scanField();
    }
  }

  noPrefactor=false;
  parseFlag("NO_PREFACTOR",noPrefactor);

  doAverageGofr=false;
  parseFlag("AVERAGE_GOFR",doAverageGofr);
  if (doAverageGofr) {
     iteration = 1;
     log.printf("  The g(r) will be averaged over all frames");
     avgGofr.resize(nhist);
  }

  doLowComm=false;
  parseFlag("LOW_COMM",doLowComm);
  if (doLowComm) {
     log.printf("  Using the low communication variant of the algorithm");
     nl_full_list=true;
     if (!doneigh) error("LOW_COMM can only be used with neighbor lists");
  }

  checkRead();

  // Setup neighbor list
  if (doneigh) {
    nl= new NeighborListParallel(atoms_lista,pbc,getPbc(),comm,log,nl_cut,nl_full_list,nl_st,nl_skin);
    requestAtoms(nl->getFullAtomList());
    log.printf("  using neighbor lists with\n");
    log.printf("  cutoff %f, and skin %f\n",nl_cut,nl_skin);
    if(nl_st>=0){
      log.printf("  update every %d steps\n",nl_st);
    } else {
      log.printf("  checking every step for dangerous builds and rebuilding as needed\n");
    }
    if (nl_full_list) {
      log.printf("  using a full neighbor list\n");
    } else {
      log.printf("  using a half neighbor list\n");
    }
  } else {
    requestAtoms(atoms_lista);
  }

  // Define heavily used expressions
  sqrt2piSigma = std::sqrt(2*pi)*sigma;
  sigmaSqr2 = 2.*sigma*sigma;
  sigmaSqr = sigma*sigma;
  deltar=maxr/(nhist-1.);
  if(deltar>sigma) error("Bin size too large! Increase NHIST");
  deltaBin = std::floor(3*sigma/deltar); // 3*sigma is hard coded
  vectorX.resize(nhist);
  vectorX2.resize(nhist);
  for(unsigned i=0;i<nhist;i++){
    vectorX[i]=deltar*i;
    vectorX2[i]=vectorX[i]*vectorX[i];
  }
}

PairEntropy::~PairEntropy(){
  if (doneigh) {
     nl->printStats();
     delete nl;
  }
  if (doOutputGofr) gofrOfile.close();
  if (doOutputIntegrand) integrandOfile.close();
}

void PairEntropy::prepare(){
  if(doneigh && nl->getStride()>0){
    if(firsttime) {
      invalidateList=true;
      firsttime=false;
    } else if ( (nl->getStride()>=0) &&  (getStep()%nl->getStride()==0) ){
      invalidateList=true;
    } else if ( (nl->getStride()<0) && !(nl->isListStillGood(getPositions())) ){
      invalidateList=true;
    } else {
      invalidateList=false;
    }
  }
}

// calculator
void PairEntropy::calculate()
{
  // Define intermediate quantities
  vector<double> gofr(nhist);
  Matrix<Vector> gofrPrime(getNumberOfAtoms(),nhist);
  vector<Tensor> gofrVirial(nhist);
  // Setup parallelization
  unsigned stride=comm.Get_size();
  unsigned rank=comm.Get_rank();
  if(serial){
    stride=1;
    rank=0;
  }else{
    stride=comm.Get_size();
    rank=comm.Get_rank();
  }
  // Normalization constant
  double volume=getBox().determinant();
  double density;
  if (density_given>0) density=density_given;
  else density=getNumberOfAtoms()/volume;
  double TwoPiDensity = 2*pi*density;
  double normConstantBase = TwoPiDensity*getNumberOfAtoms(); // Normalization of g(r)
  normConstantBase *= sqrt2piSigma; // Normalization of gaussian
  double invNormConstantBase = 1./normConstantBase; 
  // Calculation of g(r)
  if (doneigh && !doLowComm) {
    if(invalidateList){
      nl->update(getPositions());
    }
    // Loop over all atoms
    for(unsigned int i=0;i<nl->getNumberOfLocalAtoms();i++) {
       std::vector<unsigned> neighbors;
       unsigned index=nl->getIndexOfLocalAtom(i);
       neighbors=nl->getNeighbors(index);
       Vector position_index=getPosition(index);
       // Loop over neighbors
       for(unsigned int j=0;j<neighbors.size();j++) {  
         unsigned neighbor=neighbors[j];
         Vector distance=pbcDistance(position_index,getPosition(neighbor));
         double d2;
         if ( (d2=distance[0]*distance[0])<rcut2 && (d2+=distance[1]*distance[1])<rcut2 && (d2+=distance[2]*distance[2])<rcut2) {
           double distanceModulo=std::sqrt(d2);
           Vector distance_versor = distance / distanceModulo;
           unsigned bin=std::floor(distanceModulo/deltar);
           int minBin, maxBin; // These cannot be unsigned
           // Only consider contributions to g(r) of atoms less than n*sigma bins apart from the actual distance
           minBin=bin - deltaBin;
           if (minBin < 0) minBin=0;
           if (minBin > (nhist-1)) minBin=nhist-1;
           maxBin=bin +  deltaBin;
           if (maxBin > (nhist-1)) maxBin=nhist-1;
           for(int k=minBin;k<maxBin+1;k++) {
             double invNormKernel=invNormConstantBase/vectorX2[k];
             double dfunc;
             gofr[k] += kernel(vectorX[k]-distanceModulo,invNormKernel,dfunc);
             if (!doNotCalculateDerivatives()) {
                Vector value = dfunc * distance_versor;
                gofrPrime[index][k] += value;
                gofrPrime[neighbor][k] -= value;
                Tensor vv(value, distance);
                gofrVirial[k] += vv;
             }
           }
         }
       }
    }
  } else if (doneigh && doLowComm) {
    if(invalidateList){
      nl->update(getPositions());
    }
    // Loop over all atoms
    for(unsigned int i=0;i<nl->getNumberOfLocalAtoms();i++) {
       std::vector<unsigned> neighbors;
       unsigned index=nl->getIndexOfLocalAtom(i);
       neighbors=nl->getNeighbors(index);
       Vector position_index=getPosition(index);
       // Loop over neighbors
       for(unsigned int j=0;j<neighbors.size();j++) {  
         unsigned neighbor=neighbors[j];
         if(getAbsoluteIndex(index)==getAbsoluteIndex(neighbor)) continue;
         Vector distance=pbcDistance(position_index,getPosition(neighbor));
         double d2;
         if ( (d2=distance[0]*distance[0])<rcut2 && (d2+=distance[1]*distance[1])<rcut2 && (d2+=distance[2]*distance[2])<rcut2) {
           double distanceModulo=std::sqrt(d2);
           Vector distance_versor = distance / distanceModulo;
           unsigned bin=std::floor(distanceModulo/deltar);
           int minBin, maxBin; // These cannot be unsigned
           // Only consider contributions to g(r) of atoms less than n*sigma bins apart from the actual distance
           minBin=bin - deltaBin;
           if (minBin < 0) minBin=0;
           if (minBin > (nhist-1)) minBin=nhist-1;
           maxBin=bin +  deltaBin;
           if (maxBin > (nhist-1)) maxBin=nhist-1;
           for(int k=minBin;k<maxBin+1;k++) {
             double invNormKernel=invNormConstantBase/vectorX2[k];
             double dfunc;
             gofr[k] += kernel(vectorX[k]-distanceModulo,invNormKernel,dfunc)/2.0;
             if (!doNotCalculateDerivatives()) {
                Vector value = dfunc * distance_versor;
                gofrPrime[index][k] += value;
                Tensor vv(value/2.0, distance);
                gofrVirial[k] += vv;
             }
           }
         }
       }
    }
  } else {
    for(unsigned int i=rank;i<(getNumberOfAtoms()-1);i+=stride) {
      for(unsigned int j=i+1;j<getNumberOfAtoms();j++) {
         double d2;
         Vector distance=pbcDistance(getPosition(i),getPosition(j));
         if ( (d2=distance[0]*distance[0])<rcut2 && (d2+=distance[1]*distance[1])<rcut2 && (d2+=distance[2]*distance[2])<rcut2) {
           double distanceModulo=std::sqrt(d2);
           Vector distance_versor = distance / distanceModulo;
           unsigned bin=std::floor(distanceModulo/deltar);
           int minBin, maxBin; // These cannot be unsigned
           // Only consider contributions to g(r) of atoms less than n*sigma bins apart from the actual distance
           minBin=bin - deltaBin;
           if (minBin < 0) minBin=0;
           if (minBin > (nhist-1)) minBin=nhist-1;
           maxBin=bin +  deltaBin;
           if (maxBin > (nhist-1)) maxBin=nhist-1;
           for(int k=minBin;k<maxBin+1;k++) {
             double invNormKernel=invNormConstantBase/vectorX2[k];
             double dfunc;
             gofr[k] += kernel(vectorX[k]-distanceModulo,invNormKernel,dfunc);
             if (!doNotCalculateDerivatives()) {
                Vector value = dfunc * distance_versor;
                gofrPrime[i][k] += value;
                gofrPrime[j][k] -= value;
                Tensor vv(value, distance);
                gofrVirial[k] += vv;
             }
           }
         }
      }
    }
  }
  if(!serial){
    comm.Sum(gofr);
    if (!doNotCalculateDerivatives()) {
       if (!doLowComm) {
          comm.Sum(gofrPrime);
       }
       comm.Sum(gofrVirial);
    }
  }
  // Average g(r)
  if (doAverageGofr) {
     if (!doNotCalculateDerivatives()) error("Cannot use the AVERAGE_GOFR keyword when biasing");
     for(unsigned i=0;i<nhist;i++){
        avgGofr[i] += (gofr[i]-avgGofr[i])/( (double) iteration);
        gofr[i] = avgGofr[i];
     }
     iteration++;
  }
  // Average g(r)
  if (noPrefactor and !doNotCalculateDerivatives()) error("Cannot use the NO_PREFACTOR keyword when biasing");
  // Output of gofr
  if (doOutputGofr && (getStep()%outputStride==0)) outputGofr(gofr);
  // Find where g(r) is different from zero
  unsigned j=0;
  unsigned nhist_min=0;
  while (gofr[j]<1.e-10) {
     nhist_min=j;
     ++j;
  }
  // Construct integrand
  vector<double> logGofrX2(nhist);
  vector<double> integrand(nhist);
  for(unsigned j=0;j<nhist;j++){
    if (doReferenceGofr) {
       if (referenceGofr[j]<1.e-10) {
          // Not sure about this choice
          logGofrX2[j] = 0.;
       } else {
          logGofrX2[j] = std::log(gofr[j]/referenceGofr[j])*vectorX2[j];
       }
       if (gofr[j]<1.e-10) {
          integrand[j] = referenceGofr[j]*vectorX2[j];
       } else {
          integrand[j] = (gofr[j]*logGofrX2[j])+(-gofr[j]+referenceGofr[j])*vectorX2[j];
       }
    } else {
       logGofrX2[j] = std::log(gofr[j])*vectorX2[j];
       if (gofr[j]<1.e-10) {
          integrand[j] = vectorX2[j];
       } else {
          integrand[j] = (gofr[j]*logGofrX2[j])+(-gofr[j]+1)*vectorX2[j];
       }
    }
  }
  // Output of integrands
  if (doOutputIntegrand && (getStep()%outputStride==0)) outputIntegrand(integrand);
  // Integrate to obtain pair entropy;
  double pairEntropy;
  if (!noPrefactor) pairEntropy = -TwoPiDensity*integrate(integrand,deltar);
  else pairEntropy = integrate(integrand,deltar);
  // Construct integrand and integrate derivatives
  vector<Vector> deriv(getNumberOfAtoms());
  Tensor virial;
  if (!doNotCalculateDerivatives() ) {
    if (!doLowComm) {
       // Processors have already shared the gofrPrime
       for(unsigned int j=rank;j<getNumberOfAtoms();j+=stride) {
          vector<Vector> integrandDerivatives(nhist);
          for(unsigned k=nhist_min;k<nhist;k++){
            if (gofr[k]>1.e-10) {
              integrandDerivatives[k] = gofrPrime[j][k]*logGofrX2[k];
            }
          }
          // Integrate
          deriv[j] = -TwoPiDensity*integrate(integrandDerivatives,deltar);
       }
    } else {
       // Each processor handles only its own atoms
       for(unsigned int j=0;j<nl->getNumberOfLocalAtoms();j++) {
          unsigned index=nl->getIndexOfLocalAtom(j);
          vector<Vector> integrandDerivatives(nhist);
          for(unsigned k=nhist_min;k<nhist;k++){
            if (gofr[k]>1.e-10) {
              integrandDerivatives[k] = gofrPrime[index][k]*logGofrX2[k];
            }
          }
          // Integrate
          deriv[index] = -TwoPiDensity*integrate(integrandDerivatives,deltar);
       }
    }
    if(!serial){
      comm.Sum(deriv);
    }
    // Virial of positions
    // Construct virial integrand
    vector<Tensor> integrandVirial(nhist);
    for(unsigned j=nhist_min;j<nhist;j++){
      if (gofr[j]>1.e-10) {
        integrandVirial[j] = gofrVirial[j]*logGofrX2[j];
      }
    }
    // Integrate virial
    virial = -TwoPiDensity*integrate(integrandVirial,deltar);
    // Virial of volume
    if (density_given<0) {
      // Construct virial integrand
      vector<double> integrandVirialVolume(nhist);
      for(unsigned j=0;j<nhist;j++) {
        if (doReferenceGofr) {
           integrandVirialVolume[j] = (-gofr[j]+referenceGofr[j])*vectorX2[j];
        } else {
           integrandVirialVolume[j] = (-gofr[j]+1)*vectorX2[j];
        }
      }
      // Integrate virial
      virial += -TwoPiDensity*integrate(integrandVirialVolume,deltar)*Tensor::identity();
      }
  }
  // Assign output quantities
  for(unsigned i=0;i<deriv.size();i++) setAtomsDerivatives(i,deriv[i]);
  setValue           (pairEntropy);
  setBoxDerivatives  (virial);
}

double PairEntropy::kernel(double distance,double invNormKernel, double&der)const{
  // Gaussian function and derivative
  double result = invNormKernel*std::exp(-distance*distance/sigmaSqr2) ;
  der = -distance*result/sigmaSqr;
  return result;
}

double PairEntropy::integrate(vector<double> integrand, double delta)const{
  // Trapezoid rule
  double result = 0.;
  for(unsigned i=1;i<(integrand.size()-1);i++){
    result += integrand[i];
  }
  result += 0.5*integrand[0];
  result += 0.5*integrand[integrand.size()-1];
  result *= delta;
  return result;
}

Vector PairEntropy::integrate(vector<Vector> integrand, double delta)const{
  // Trapezoid rule
  Vector result;
  for(unsigned i=1;i<(integrand.size()-1);i++){
      result += integrand[i];
  }
  result += 0.5*integrand[0];
  result += 0.5*integrand[integrand.size()-1];
  result *= delta;
  return result;
}

Tensor PairEntropy::integrate(vector<Tensor> integrand, double delta)const{
  // Trapezoid rule
  Tensor result;
  for(unsigned i=1;i<(integrand.size()-1);i++){
      result += integrand[i];
  }
  result += 0.5*integrand[0];
  result += 0.5*integrand[integrand.size()-1];
  result *= delta;
  return result;
}

void PairEntropy::outputGofr(vector<double> gofr) {
  for(unsigned i=0;i<gofr.size();i++){
     gofrOfile.printField("r",vectorX[i]).printField("gofr",gofr[i]).printField();
  }
  gofrOfile.printf("\n");
  gofrOfile.printf("\n");
}

void PairEntropy::outputIntegrand(vector<double> integrand) {
  for(unsigned i=0;i<integrand.size();i++){
     integrandOfile.printField("r",vectorX[i]).printField("integrand",integrand[i]).printField();
  }
  integrandOfile.printf("\n");
  integrandOfile.printf("\n");
}


}
}
src/colvar/PairEntropyMulticomp.cpp0000777000175000017500000014440014000306207016765 0ustar  maplemaple/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   Copyright (c) 2011-2016 The plumed team
   (see the PEOPLE file at the root of the distribution for a list of names)
   See http://www.plumed.org for more information.
   This file is part of plumed, version 2.
   plumed is free software: you can redistribute it and/or modify
   it under the terms of the GNU Lesser General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.
   plumed is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU Lesser General Public License for more details.
   You should have received a copy of the GNU Lesser General Public License
   along with plumed.  If not, see <http://www.gnu.org/licenses/>.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
#include "Colvar.h"
#include "ActionRegister.h"
#include "tools/NeighborListParallel.h"
#include "tools/Communicator.h"
#include "tools/Tools.h"

#include <string>

using namespace std;

namespace PLMD{
namespace colvar{

//+PLUMEDOC COLVAR PAIRENTROPY_MULTICOMP
/*
Calculate the per-atom global pair entropy of a two-component system using the expression:
\f[
s=-2\pi (\rho_A^2/\rho) k_B \int\limits_0^{r_{\mathrm{max}}} \left [ g_{AA}(r) \ln g_{AA}(r) - g_{AA}(r) + 1 \right ] r^2 dr 
- 4\pi (\rho_A\rho_B/\rho) k_B \int\limits_0^{r_{\mathrm{max}}} \left [ g_{AB}(r) \ln g_{AB}(r) - g_{AB}(r) + 1 \right ] r^2 dr 
- 2\pi (\rho_B^2\rho) k_B \int\limits_0^{r_{\mathrm{max}}} \left [ g_{BB}(r) \ln g_{BB}(r) - g_{BB}(r) + 1 \right ] r^2 dr 
\f]
where \f$ g_{\alpha\beta}(r) $\f are the pair distribution functions of the pairs and \f$ r_{\mathrm{max}} $\f is a cutoff in the integration (MAXR).
\f$ \rho_A $\f is the density of A atoms, \f$ \rho_B $\f is the density of B atoms and \f$ \rho $\f is the total density.
For the integration the interval from 0 to  \f$ r_{\mathrm{max}} $\f is partitioned in NHIST equal intervals. 
To make the calculation of \f$ g_{\alpha\beta}(r) $\f differentiable, the following function is used:
\f[
g_{\alpha\beta}(r) = \frac{N_A+N_B}{4 \pi \rho N_{\alpha} N_{\beta} r^2} \sum\limits_{i \in \alpha} \sum\limits_{i \in \beta} \frac{1}{\sqrt{2 \pi \sigma^2}} e^{-(r-r_{ij})^2/(2\sigma^2)} ,
\f]
where \f$ \rho $\f is the density and \f$ sigma $\f is a broadening parameter (SIGMA).  
\par Example)
The following input tells plumed to calculate the pair entropy of a system of 250 atoms of type A and 250 atoms of type B.
\verbatim
PAIRENTROPY_MULTICOMP ...
 LABEL=S2
 GROUPA=1-250
 GROUPB=251-500
 MAXR=0.6
 SIGMA=0.01
 NHIST=100
 NLIST
 NL_CUTOFF=0.65
 NL_STRIDE=10
... PAIRENTROPY_MULTICOMP
\endverbatim
*/
//+ENDPLUMEDOC

class PairEntropyMulticomp : public Colvar {
  bool pbc;
  bool serial;
  bool do_pairs;
  bool doneigh;
  bool do_ignore_aa, do_ignore_bb;
  NeighborListParallel *nlAA, *nlBB, *nlAB, *nlBA;
  bool invalidateListAA, invalidateListAB, invalidateListBA, invalidateListBB;
  bool firsttimeAA, firsttimeAB, firsttimeBA, firsttimeBB;
  vector<AtomNumber> ga_lista,gb_lista,full_lista;
  double maxr, sigma;
  unsigned nhist;
  double rcut2;
  double invSqrt2piSigma, sigmaSqr2, sigmaSqr, invNormKernel;
  double deltar;
  unsigned deltaBin;
  unsigned numberOfAatoms, numberOfBatoms;
  std::vector<double> vectorX, vectorX2;
  // Integration routines
  double integrate(vector<double> integrand, double delta)const;
  Vector integrate(vector<Vector> integrand, double delta)const;
  Tensor integrate(vector<Tensor> integrand, double delta)const;
  // Output gofr and integrand
  void outputGofr(vector<double> gofrAA, vector<double> gofrAB, vector<double> gofrBB);
  void outputIntegrand(vector<double> gofrAA, vector<double> gofrAB, vector<double> gofrBB);
  mutable PLMD::OFile gofrOfile, integrandOfile;
  bool doOutputGofr;
  bool doOutputIntegrand;
  unsigned outputStride;
  // Average g(r)
  bool doAverageGofr;
  vector<double> avgGofrAA;
  vector<double> avgGofrAB;
  vector<double> avgGofrBB;
  unsigned iteration;
  unsigned averageGofrTau;
  // Kernel to calculate g(r)
  double kernel(double distance, double&der)const;
  // Low communication variant
  bool doLowComm;
public:
  explicit PairEntropyMulticomp(const ActionOptions&);
  ~PairEntropyMulticomp();
// active methods:
  virtual void calculate();
  virtual void prepare();
  static void registerKeywords( Keywords& keys );
};

PLUMED_REGISTER_ACTION(PairEntropyMulticomp,"PAIRENTROPY_MULTICOMP")

void PairEntropyMulticomp::registerKeywords( Keywords& keys ){
  Colvar::registerKeywords(keys);
  keys.addFlag("SERIAL",false,"Perform the calculation in serial - for debug purpose");
  keys.addFlag("NLIST",false,"Use a neighbour list to speed up the calculation");
  keys.addFlag("INDIVIDUAL_PAIRS",false,"Obtain pair entropy of AA, AB, and BB pairs");
  keys.addFlag("OUTPUT_GOFR",false,"Output g(r) of AA, AB, and BB pairs");
  keys.addFlag("OUTPUT_INTEGRAND",false,"Output integrand of AA, AB, and BB pairs");
  keys.addFlag("IGNORE_AA",false,"Ignore the calculation of the AA interaction");
  keys.addFlag("IGNORE_BB",false,"Ignore the calculation of the BB interaction");
  keys.addFlag("LOW_COMM",false,"Use the low communication variant of the algorithm.");
  keys.add("optional","OUTPUT_STRIDE","The frequency with which the output is written to files");
  keys.add("optional","NL_CUTOFF","The cutoff for the neighbour list");
  keys.add("optional","NL_STRIDE","The frequency with which we are updating the atoms in the neighbour list. If non specified or negative, it checks every step and rebuilds as needed.");
  keys.add("atoms","GROUPA","First list of atoms");
  keys.add("atoms","GROUPB","Second list of atoms");
  keys.add("compulsory","MAXR","1","Maximum distance for the radial distribution function ");
  keys.add("optional","NHIST","Number of bins in the rdf ");
  keys.add("compulsory","SIGMA","0.1","Width of gaussians ");
  keys.addFlag("AVERAGE_GOFR",false,"Average g(r) over time");
  keys.add("optional","AVERAGE_GOFR_TAU","Characteristic length of a window in which to average the g(r). It is in units of iterations and should be an integer. Zero corresponds to an normal average (infinite window).");
  keys.addOutputComponent("pairAA","INDIVIDUAL_PAIRS","Pair AA contribution to the multicomponent pair entropy");
  keys.addOutputComponent("pairAB","INDIVIDUAL_PAIRS","Pair AB contribution to the multicomponent pair entropy");
  keys.addOutputComponent("pairBB","INDIVIDUAL_PAIRS","Pair BB contribution to the multicomponent pair entropy");
  keys.addOutputComponent("full","INDIVIDUAL_PAIRS","Total multicomponent pair entropy");

}

PairEntropyMulticomp::PairEntropyMulticomp(const ActionOptions&ao):
PLUMED_COLVAR_INIT(ao),
pbc(true),
serial(false),
do_pairs(false),
invalidateListAA(true),
invalidateListAB(true),
invalidateListBA(true),
invalidateListBB(true),
firsttimeAA(true),
firsttimeAB(true),
firsttimeBA(true),
firsttimeBB(true)
{

  parseFlag("SERIAL",serial);

  parseAtomList("GROUPA",ga_lista);
  parseAtomList("GROUPB",gb_lista);

  bool nopbc=!pbc;
  parseFlag("NOPBC",nopbc);
  pbc=!nopbc;

// neighbor list stuff
  doneigh=false;
  bool nl_full_list=false;
  bool nl_full_list_cross=false;
  bool do_pair=false;
  double nl_cut=0.0;
  int nl_st=-1;
  double nl_skin;
  parseFlag("NLIST",doneigh);
  if(doneigh){
   parse("NL_CUTOFF",nl_cut);
   if(nl_cut<=0.0) error("NL_CUTOFF should be explicitly specified and positive");
   parse("NL_STRIDE",nl_st);
  }

// low communication stuff
  doLowComm=false;
  parseFlag("LOW_COMM",doLowComm);
  if(doLowComm) {
    log.printf("  using the low communication variant of the algorithm\n");
    nl_full_list=true;
  }

  /*
  log.printf("  between two groups of %u and %u atoms\n",static_cast<unsigned>(ga_lista.size()),static_cast<unsigned>(gb_lista.size()));
  log.printf("  first group:\n");
  for(unsigned int i=0;i<ga_lista.size();++i){
   if ( (i+1) % 25 == 0 ) log.printf("  \n");
   log.printf("  %d", ga_lista[i].serial());
  }
  log.printf("  \n  second group:\n");
  for(unsigned int i=0;i<gb_lista.size();++i){
   if ( (i+1) % 25 == 0 ) log.printf("  \n");
   log.printf("  %d", gb_lista[i].serial());
  }
  log.printf("  \n");
  */
  if(pbc) log.printf("  using periodic boundary conditions\n");
  else    log.printf("  without periodic boundary conditions\n");

  parse("MAXR",maxr);
  log.printf("  Integration in the interval from 0. to %f . \n", maxr );
  parse("SIGMA",sigma);
  log.printf("  The pair distribution functions is calculated with a Gaussian kernel with deviation %f . \n", sigma);
  double rcut = maxr + 3*sigma;
  rcut2 = (maxr + 3*sigma)*(maxr + 3*sigma);  // 3*sigma is hard coded
  if(doneigh){
    if(nl_cut<rcut) error("NL_CUTOFF should be larger than MAXR + 3*SIGMA");
    nl_skin=nl_cut-maxr;
  }
  nhist=ceil(maxr/(sigma/2.)) + 1; // Default value
  parse("NHIST",nhist);
  log.printf("  The interval is partitioned in %d equal parts and the integration is perfromed with the trapezoid rule. \n", nhist );
 
  // Construct full list 
  full_lista.reserve ( ga_lista.size() + gb_lista.size() );
  full_lista.insert (  full_lista.end() , ga_lista.begin(),  ga_lista.end() );
  full_lista.insert (  full_lista.end() , gb_lista.begin(),  gb_lista.end() );
  numberOfAatoms=ga_lista.size();
  numberOfBatoms=gb_lista.size();

  if(!(gb_lista.size()>0)){
    error("The group of atoms GROUPB has not been specified");
  }

  requestAtoms(full_lista);
 
  doOutputGofr=false;
  parseFlag("OUTPUT_GOFR",doOutputGofr);
  if (doOutputGofr) { 
     log.printf("  The g(r) will be written to a file \n.");
     gofrOfile.link(*this);
     gofrOfile.open("gofr.txt");
  }
  doOutputIntegrand=false;
  parseFlag("OUTPUT_INTEGRAND",doOutputIntegrand);
  if (doOutputIntegrand) {
     log.printf("  The integrand will be written to a file \n.");
     integrandOfile.link(*this);
     integrandOfile.open("integrand.txt");
  }
  outputStride=1;
  parse("OUTPUT_STRIDE",outputStride);
  if (outputStride!=1 && !doOutputGofr && !doOutputIntegrand) error("Cannot specify OUTPUT_STRIDE if OUTPUT_GOFR or OUTPUT_INTEGRAND not used");
  if (outputStride<1) error("The output stride specified with OUTPUT_STRIDE must be greater than or equal to one.");
  if (outputStride>1) log.printf("  The output stride to write g(r) or the integrand is %d \n", outputStride);


  doAverageGofr=false;
  parseFlag("AVERAGE_GOFR",doAverageGofr);
  if (doAverageGofr) {
     iteration = 1;
     avgGofrAA.resize(nhist);
     avgGofrAB.resize(nhist);
     avgGofrBB.resize(nhist);
  }
  averageGofrTau=0;
  parse("AVERAGE_GOFR_TAU",averageGofrTau);
  if (averageGofrTau!=0 && !doAverageGofr) error("AVERAGE_GOFR_TAU specified but AVERAGE_GOFR not given. Specify AVERAGE_GOFR or remove AVERAGE_GOFR_TAU");
  if (doAverageGofr && averageGofrTau==0) log.printf("The g(r) will be averaged over all frames \n");
  if (doAverageGofr && averageGofrTau!=0) log.printf("The g(r) will be averaged with a window of %d steps \n", averageGofrTau);


  parseFlag("INDIVIDUAL_PAIRS",do_pairs);
  if (do_pairs) log.printf("  The AA, AB, and BB contributions will be computed separately \n");

  do_ignore_aa=false;
  parseFlag("IGNORE_AA",do_ignore_aa);
  if (do_ignore_aa) log.printf("  The AA term will be ignored \n");
  do_ignore_bb=false;
  parseFlag("IGNORE_BB",do_ignore_bb);
  if (do_ignore_bb) log.printf("  The BB term will be ignored \n");

  checkRead();

  if (doneigh) {
     //nl= new NeighborListParallel(full_lista,pbc,getPbc(),comm,log,nl_cut,nl_st,nl_skin);
     nlAA = new NeighborListParallel(ga_lista,pbc,getPbc(),comm,log,nl_cut,nl_full_list,nl_st,nl_skin);
     nlAB = new NeighborListParallel(ga_lista,gb_lista,do_pair,pbc,getPbc(),comm,log,nl_cut,nl_full_list_cross,nl_st,nl_skin);
     if (doLowComm) nlBA = new NeighborListParallel(gb_lista,ga_lista,do_pair,pbc,getPbc(),comm,log,nl_cut,nl_full_list_cross,nl_st,nl_skin);
     nlBB = new NeighborListParallel(gb_lista,pbc,getPbc(),comm,log,nl_cut,nl_full_list,nl_st,nl_skin);
     log.printf("  using neighbor lists with\n");
     log.printf("  cutoff %f, and skin %f\n",nl_cut,nl_skin);
     if(nl_st>=0){
       log.printf("  update every %d steps\n",nl_st);
     } else {
       log.printf("  checking every step for dangerous builds and rebuilding as needed\n");
     }
  }


  // Define heavily used expressions
  double sqrt2piSigma = std::sqrt(2*pi)*sigma;
  invSqrt2piSigma = 1./sqrt2piSigma;
  sigmaSqr2 = 2.*sigma*sigma;
  sigmaSqr = sigma*sigma;
  deltar=maxr/(nhist-1.);
  deltaBin = std::floor(3*sigma/deltar); // 3*sigma is hard coded

  vectorX.resize(nhist);
  vectorX2.resize(nhist);
  for(unsigned i=0;i<nhist;++i){
    vectorX[i]=deltar*i;
    vectorX2[i]=vectorX[i]*vectorX[i];
  }

  // Define output components
  if (do_pairs) {
    addComponentWithDerivatives("pairAA"); componentIsNotPeriodic("pairAA");
    addComponentWithDerivatives("pairAB"); componentIsNotPeriodic("pairAB");
    addComponentWithDerivatives("pairBB"); componentIsNotPeriodic("pairBB");
    addComponentWithDerivatives("full"); componentIsNotPeriodic("full");
  } else {
    addValueWithDerivatives(); setNotPeriodic();
  }
}

PairEntropyMulticomp::~PairEntropyMulticomp(){
  if (doneigh) {
     if (!do_ignore_aa) nlAA->printStats();
     nlAB->printStats();
     if (doLowComm) nlBA->printStats();
     if (!do_ignore_bb) nlBB->printStats();
     delete nlAA;
     delete nlAB;
     if (doLowComm) delete nlBA;
     delete nlBB;
  }
}

void PairEntropyMulticomp::prepare(){
  if(!do_ignore_aa && doneigh && nlAA->getStride()>0){
    if(firsttimeAA) {
      invalidateListAA=true;
      firsttimeAA=false;
    } else if ( (nlAA->getStride()>=0) &&  (getStep()%nlAA->getStride()==0) ){
      invalidateListAA=true;
    } else {
      invalidateListAA=false;
    }
  }
  if(doneigh && nlAB->getStride()>0){
    if(firsttimeAB) {
      invalidateListAB=true;
      firsttimeAB=false;
    } else if ( (nlAB->getStride()>=0) &&  (getStep()%nlAB->getStride()==0) ){
      invalidateListAB=true;
    } else {
      invalidateListAB=false;
    }
  }
  if (doLowComm) {
    if(doneigh && nlBA->getStride()>0){
      if(firsttimeBA) {
        invalidateListBA=true;
        firsttimeBA=false;
      } else if ( (nlBA->getStride()>=0) &&  (getStep()%nlBA->getStride()==0) ){
        invalidateListBA=true;
      } else {
        invalidateListBA=false;
      }
    }
  }
  if(!do_ignore_bb && doneigh && nlBB->getStride()>0){
    if(firsttimeBB) {
      invalidateListBB=true;
      firsttimeBB=false;
    } else if ( (nlBB->getStride()>=0) &&  (getStep()%nlBB->getStride()==0) ){
      invalidateListBB=true;
    /*
    } else if ( (nlBB->getStride()<0) && !(nlBB->isListStillGood(getPositions())) ){
      invalidateListBB=true;
    */
    } else {
      invalidateListBB=false;
    }
  }
}

// calculator
void PairEntropyMulticomp::calculate()
{
  // Define output quantities
  //double pairEntropy;
  vector<Vector> derivAA(getNumberOfAtoms());
  vector<Vector> derivAB(getNumberOfAtoms());
  vector<Vector> derivBB(getNumberOfAtoms());
  // Define intermediate quantities
  vector<double> gofrAA(nhist);
  vector<double> gofrAB(nhist);
  vector<double> gofrBB(nhist);
  Matrix<Vector> gofrPrimeAA(nhist,getNumberOfAtoms());
  Matrix<Vector> gofrPrimeAB(nhist,getNumberOfAtoms());
  Matrix<Vector> gofrPrimeBB(nhist,getNumberOfAtoms());
  vector<Tensor> gofrVirialAA(nhist);
  vector<Tensor> gofrVirialAB(nhist);
  vector<Tensor> gofrVirialBB(nhist);
  // Calculate volume and density
  double volume=getBox().determinant();
  double density=getNumberOfAtoms()/volume; // This is (NA+NB)/V
  double densityA=numberOfAatoms/volume; // This is NA/V
  double densityB=numberOfBatoms/volume; // This is NB/V
  // Normalization of g(r)s
  double normConstantBaseAA = 2*pi*density*numberOfAatoms*(numberOfAatoms-1) / getNumberOfAtoms();
  double normConstantBaseAB = 4*pi*density*numberOfAatoms*numberOfBatoms / getNumberOfAtoms();
  double normConstantBaseBB = 2*pi*density*numberOfBatoms*(numberOfBatoms-1) / getNumberOfAtoms();
  double invNormConstantBaseAA = invSqrt2piSigma/normConstantBaseAA;
  double invNormConstantBaseAB = invSqrt2piSigma/normConstantBaseAB;
  double invNormConstantBaseBB = invSqrt2piSigma/normConstantBaseBB;
  // Setup parallelization
  unsigned stride=comm.Get_size();
  unsigned rank=comm.Get_rank();
  if(serial){
    stride=1;
    rank=0;
  }else{
    stride=comm.Get_size();
    rank=comm.Get_rank();
  }
  if (doneigh && !doLowComm) {
     if(!do_ignore_aa && invalidateListAA){
        vector<Vector> a_positions(getPositions().begin(),getPositions().begin() + ga_lista.size());
        nlAA->update(a_positions);
     }
     if(invalidateListAB){
        nlAB->update(getPositions());
     }
     if(!do_ignore_bb && invalidateListBB){
        vector<Vector> b_positions(getPositions().begin() + ga_lista.size(), getPositions().end() );
        nlBB->update(b_positions);
     }
     if (!do_ignore_aa) {
       // Loop over A atoms
       for(unsigned int i=0;i<nlAA->getNumberOfLocalAtoms();i++) {
          std::vector<unsigned> neighbors;
          unsigned index=nlAA->getIndexOfLocalAtom(i);
          neighbors=nlAA->getNeighbors(index);
          // Loop over A type neighbors
          for(unsigned int j=0;j<neighbors.size();j++) {  
             double dfunc, d2;
             Vector distance;
             Vector distance_versor;
             unsigned i0=index;
             unsigned i1=neighbors[j];
             if(getAbsoluteIndex(i0)==getAbsoluteIndex(i1)) continue;
             if(pbc){
              distance=pbcDistance(getPosition(i0),getPosition(i1));
             } else {
              distance=delta(getPosition(i0),getPosition(i1));
             }
             if ( (d2=distance[0]*distance[0])<rcut2 && (d2+=distance[1]*distance[1])<rcut2 && (d2+=distance[2]*distance[2])<rcut2) {
               //if (index==200) std::cout  << "NL: " << neighbors[j] << "\n";
               double distanceModulo=std::sqrt(d2);
               Vector distance_versor = distance / distanceModulo;
               unsigned bin=std::floor(distanceModulo/deltar);
               int minBin, maxBin; // These cannot be unsigned
               // Only consider contributions to g(r) of atoms less than n*sigma bins apart from the actual distance
               minBin=bin - deltaBin;
               if (minBin < 0) minBin=0;
               if (minBin > (nhist-1)) minBin=nhist-1;
               maxBin=bin +  deltaBin;
               if (maxBin > (nhist-1)) maxBin=nhist-1;
               for(int k=minBin;k<maxBin+1;k+=1) {
                 invNormKernel=invNormConstantBaseAA/vectorX2[k];
                 gofrAA[k] += kernel(vectorX[k]-distanceModulo, dfunc);
                 if (!doNotCalculateDerivatives()) {
                    Vector value = dfunc * distance_versor;
                    gofrPrimeAA[k][i0] += value;
                    gofrPrimeAA[k][i1] -= value;
                    Tensor vv(value, distance);
                    gofrVirialAA[k] += vv;
                 }      
               }
             }
          }
       }
    }
    if (!do_ignore_bb) {
       // Loop over B atoms
       for(unsigned int i=0;i<nlBB->getNumberOfLocalAtoms();i++) {
          std::vector<unsigned> neighbors;
          unsigned index=nlBB->getIndexOfLocalAtom(i);
          neighbors=nlBB->getNeighbors(index);
          // Loop over B type neighbors
          for(unsigned int j=0;j<neighbors.size();j++) {  
             double dfunc, d2;
             Vector distance;
             Vector distance_versor;
             unsigned i0=index+ga_lista.size();
             unsigned i1=neighbors[j]+ga_lista.size();
             if(getAbsoluteIndex(i0)==getAbsoluteIndex(i1)) continue;
             if(pbc){
              distance=pbcDistance(getPosition(i0),getPosition(i1));
             } else {
              distance=delta(getPosition(i0),getPosition(i1));
             }
             if ( (d2=distance[0]*distance[0])<rcut2 && (d2+=distance[1]*distance[1])<rcut2 && (d2+=distance[2]*distance[2])<rcut2) {
               double distanceModulo=std::sqrt(d2);
               Vector distance_versor = distance / distanceModulo;
               unsigned bin=std::floor(distanceModulo/deltar);
               int minBin, maxBin; // These cannot be unsigned
               // Only consider contributions to g(r) of atoms less than n*sigma bins apart from the actual distance
               minBin=bin - deltaBin;
               if (minBin < 0) minBin=0;
               if (minBin > (nhist-1)) minBin=nhist-1;
               maxBin=bin +  deltaBin;
               if (maxBin > (nhist-1)) maxBin=nhist-1;
               for(int k=minBin;k<maxBin+1;k+=1) {
                 invNormKernel=invNormConstantBaseBB/vectorX2[k];
                 gofrBB[k] += kernel(vectorX[k]-distanceModulo, dfunc);
                 if (!doNotCalculateDerivatives()) {
                    Vector value = dfunc * distance_versor;
                    gofrPrimeBB[k][i0] += value;
                    gofrPrimeBB[k][i1] -= value;
                    Tensor vv(value, distance);
                    gofrVirialBB[k] += vv;
                 }      
               }
             }
          }
       }
    }
    // Loop over A atoms
    for(unsigned int i=0;i<nlAB->getNumberOfLocalAtoms();i++) {
       std::vector<unsigned> neighbors;
       unsigned index=nlAB->getIndexOfLocalAtom(i);
       neighbors=nlAB->getNeighbors(index);
       // Loop over B type neighbors
       for(unsigned int j=0;j<neighbors.size();j++) {  
          double dfunc, d2;
          Vector distance;
          Vector distance_versor;
          unsigned i0=index;
          unsigned i1=neighbors[j];
          if(getAbsoluteIndex(i0)==getAbsoluteIndex(i1)) continue;
          if(pbc){
           distance=pbcDistance(getPosition(i0),getPosition(i1));
          } else {
           distance=delta(getPosition(i0),getPosition(i1));
          }
          if ( (d2=distance[0]*distance[0])<rcut2 && (d2+=distance[1]*distance[1])<rcut2 && (d2+=distance[2]*distance[2])<rcut2) {
            double distanceModulo=std::sqrt(d2);
            Vector distance_versor = distance / distanceModulo;
            unsigned bin=std::floor(distanceModulo/deltar);
            int minBin, maxBin; // These cannot be unsigned
            // Only consider contributions to g(r) of atoms less than n*sigma bins apart from the actual distance
            minBin=bin - deltaBin;
            if (minBin < 0) minBin=0;
            if (minBin > (nhist-1)) minBin=nhist-1;
            maxBin=bin +  deltaBin;
            if (maxBin > (nhist-1)) maxBin=nhist-1;
            for(int k=minBin;k<maxBin+1;k+=1) {
              invNormKernel=invNormConstantBaseAB/vectorX2[k];
              gofrAB[k] += kernel(vectorX[k]-distanceModulo, dfunc);
              if (!doNotCalculateDerivatives()) {
                 Vector value = dfunc * distance_versor;
                 gofrPrimeAB[k][i0] += value;
                 gofrPrimeAB[k][i1] -= value;
                 Tensor vv(value, distance);
                 gofrVirialAB[k] += vv;
              }      
            }
          }
       }
    }
  } else if (!doneigh && !doLowComm) {
     // Loop over pairs
     for(unsigned int i=rank;i<(getNumberOfAtoms()-1);i+=stride) {
        for(unsigned int j=i+1;j<getNumberOfAtoms();j+=1) {
           double dfunc, d2;
           Vector distance;
           Vector distance_versor;
           if(getAbsoluteIndex(i)==getAbsoluteIndex(j)) continue;
           if(pbc){
            distance=pbcDistance(getPosition(i),getPosition(j));
           } else {
            distance=delta(getPosition(i),getPosition(j));
           }
           if ( (d2=distance[0]*distance[0])<rcut2 && (d2+=distance[1]*distance[1])<rcut2 && (d2+=distance[2]*distance[2])<rcut2) {
             double distanceModulo=std::sqrt(d2);
             Vector distance_versor = distance / distanceModulo;
             unsigned bin=std::floor(distanceModulo/deltar);
             int minBin, maxBin; // These cannot be unsigned
             // Only consider contributions to g(r) of atoms less than n*sigma bins apart from the actual distance
             minBin=bin - deltaBin;
             if (minBin < 0) minBin=0;
             if (minBin > (nhist-1)) minBin=nhist-1;
             maxBin=bin +  deltaBin;
             if (maxBin > (nhist-1)) maxBin=nhist-1;
             //if (i==200 && j<numberOfAatoms) std::cout << "NO: " << j << "\n";
             for(int k=minBin;k<maxBin+1;k+=1) {
               // To which gofr does this pair of atoms contribute?
               if (i<numberOfAatoms && j<numberOfAatoms) {
                 if (!do_ignore_aa) {
                    // AA case
                    invNormKernel=invNormConstantBaseAA/vectorX2[k];
                    gofrAA[k] += kernel(vectorX[k]-distanceModulo, dfunc);
                    if (!doNotCalculateDerivatives()) {
                       Vector value = dfunc * distance_versor;
                       gofrPrimeAA[k][i] += value;
                       gofrPrimeAA[k][j] -= value;
                       Tensor vv(value, distance);
                       gofrVirialAA[k] += vv;
                    }
                 }
               } else if (i>=numberOfAatoms && j>=numberOfAatoms) {
                    if (!do_ignore_bb) {
                       // BB case
                       invNormKernel=invNormConstantBaseBB/vectorX2[k];
                       gofrBB[k] += kernel(vectorX[k]-distanceModulo, dfunc);
                       if (!doNotCalculateDerivatives()) {
                          Vector value = dfunc * distance_versor;
                          gofrPrimeBB[k][i] += value;
                          gofrPrimeBB[k][j] -= value;
                          Tensor vv(value, distance);
                          gofrVirialBB[k] += vv;
                       }
                    }
               } else {
                    // AB or BA case
                    invNormKernel=invNormConstantBaseAB/vectorX2[k];
                    gofrAB[k] += kernel(vectorX[k]-distanceModulo, dfunc);
                    if (!doNotCalculateDerivatives()) {
                       Vector value = dfunc * distance_versor;
                       gofrPrimeAB[k][i] += value;
                       gofrPrimeAB[k][j] -= value;
                       Tensor vv(value, distance);
                       gofrVirialAB[k] += vv;
                    }
               }
             }
           }
        }
     }
  } else if (doneigh && doLowComm) {
     if(!do_ignore_aa && invalidateListAA){
        vector<Vector> a_positions(getPositions().begin(),getPositions().begin() + ga_lista.size());
        nlAA->update(a_positions);
     }
     if(invalidateListAB){
        nlAB->update(getPositions());
     }
     if(invalidateListBA){
        vector<Vector> a_positions(getPositions().begin(),getPositions().begin() + ga_lista.size());
        vector<Vector> b_positions(getPositions().begin() + ga_lista.size(), getPositions().end() );
        vector<Vector> positions;
        positions.reserve( b_positions.size() + a_positions.size() );
        positions.insert (  positions.end() , b_positions.begin(),  b_positions.end() );
        positions.insert (  positions.end() , a_positions.begin(),  a_positions.end() );
        nlBA->update(positions);
     }
     if(!do_ignore_bb && invalidateListBB){
        vector<Vector> b_positions(getPositions().begin() + ga_lista.size(), getPositions().end() );
        nlBB->update(b_positions);
     }
     if (!do_ignore_aa) {
       // Loop over A atoms
       for(unsigned int i=0;i<nlAA->getNumberOfLocalAtoms();i++) {
          std::vector<unsigned> neighbors;
          unsigned index=nlAA->getIndexOfLocalAtom(i);
          neighbors=nlAA->getNeighbors(index);
          // Loop over A type neighbors
          for(unsigned int j=0;j<neighbors.size();j++) {  
             double dfunc, d2;
             Vector distance;
             Vector distance_versor;
             unsigned i0=index;
             unsigned i1=neighbors[j];
             if(getAbsoluteIndex(i0)==getAbsoluteIndex(i1)) continue;
             if(pbc){
              distance=pbcDistance(getPosition(i0),getPosition(i1));
             } else {
              distance=delta(getPosition(i0),getPosition(i1));
             }
             if ( (d2=distance[0]*distance[0])<rcut2 && (d2+=distance[1]*distance[1])<rcut2 && (d2+=distance[2]*distance[2])<rcut2) {
               //if (index==200) std::cout  << "NL: " << neighbors[j] << "\n";
               double distanceModulo=std::sqrt(d2);
               Vector distance_versor = distance / distanceModulo;
               unsigned bin=std::floor(distanceModulo/deltar);
               int minBin, maxBin; // These cannot be unsigned
               // Only consider contributions to g(r) of atoms less than n*sigma bins apart from the actual distance
               minBin=bin - deltaBin;
               if (minBin < 0) minBin=0;
               if (minBin > (nhist-1)) minBin=nhist-1;
               maxBin=bin +  deltaBin;
               if (maxBin > (nhist-1)) maxBin=nhist-1;
               for(int k=minBin;k<maxBin+1;k+=1) {
                 invNormKernel=invNormConstantBaseAA/vectorX2[k];
                 gofrAA[k] += kernel(vectorX[k]-distanceModulo, dfunc)/2.;
                 if (!doNotCalculateDerivatives()) {
                    Vector value = dfunc * distance_versor;
                    gofrPrimeAA[k][i0] += value;
                    //gofrPrimeAA[k][i1] -= value;
                    Tensor vv(value/2., distance);
                    gofrVirialAA[k] += vv;
                 }      
               }
             }
          }
       }
    }
    if (!do_ignore_bb) {
       // Loop over B atoms
       for(unsigned int i=0;i<nlBB->getNumberOfLocalAtoms();i++) {
          std::vector<unsigned> neighbors;
          unsigned index=nlBB->getIndexOfLocalAtom(i);
          neighbors=nlBB->getNeighbors(index);
          // Loop over B type neighbors
          for(unsigned int j=0;j<neighbors.size();j++) {  
             double dfunc, d2;
             Vector distance;
             Vector distance_versor;
             unsigned i0=index+ga_lista.size();
             unsigned i1=neighbors[j]+ga_lista.size();
             if(getAbsoluteIndex(i0)==getAbsoluteIndex(i1)) continue;
             if(pbc){
              distance=pbcDistance(getPosition(i0),getPosition(i1));
             } else {
              distance=delta(getPosition(i0),getPosition(i1));
             }
             if ( (d2=distance[0]*distance[0])<rcut2 && (d2+=distance[1]*distance[1])<rcut2 && (d2+=distance[2]*distance[2])<rcut2) {
               double distanceModulo=std::sqrt(d2);
               Vector distance_versor = distance / distanceModulo;
               unsigned bin=std::floor(distanceModulo/deltar);
               int minBin, maxBin; // These cannot be unsigned
               // Only consider contributions to g(r) of atoms less than n*sigma bins apart from the actual distance
               minBin=bin - deltaBin;
               if (minBin < 0) minBin=0;
               if (minBin > (nhist-1)) minBin=nhist-1;
               maxBin=bin +  deltaBin;
               if (maxBin > (nhist-1)) maxBin=nhist-1;
               for(int k=minBin;k<maxBin+1;k+=1) {
                 invNormKernel=invNormConstantBaseBB/vectorX2[k];
                 gofrBB[k] += kernel(vectorX[k]-distanceModulo, dfunc)/2.;
                 if (!doNotCalculateDerivatives()) {
                    Vector value = dfunc * distance_versor;
                    gofrPrimeBB[k][i0] += value;
                    //gofrPrimeBB[k][i1] -= value;
                    Tensor vv(value/2., distance);
                    gofrVirialBB[k] += vv;
                 }      
               }
             }
          }
       }
    }
    // Loop over A atoms
    for(unsigned int i=0;i<nlAB->getNumberOfLocalAtoms();i++) {
       std::vector<unsigned> neighbors;
       unsigned index=nlAB->getIndexOfLocalAtom(i);
       neighbors=nlAB->getNeighbors(index);
       // Loop over B type neighbors
       for(unsigned int j=0;j<neighbors.size();j++) {  
          double dfunc, d2;
          Vector distance;
          Vector distance_versor;
          unsigned i0=index;
          unsigned i1=neighbors[j];
          if(getAbsoluteIndex(i0)==getAbsoluteIndex(i1)) continue;
          if(pbc){
           distance=pbcDistance(getPosition(i0),getPosition(i1));
          } else {
           distance=delta(getPosition(i0),getPosition(i1));
          }
          if ( (d2=distance[0]*distance[0])<rcut2 && (d2+=distance[1]*distance[1])<rcut2 && (d2+=distance[2]*distance[2])<rcut2) {
            double distanceModulo=std::sqrt(d2);
            Vector distance_versor = distance / distanceModulo;
            unsigned bin=std::floor(distanceModulo/deltar);
            int minBin, maxBin; // These cannot be unsigned
            // Only consider contributions to g(r) of atoms less than n*sigma bins apart from the actual distance
            minBin=bin - deltaBin;
            if (minBin < 0) minBin=0;
            if (minBin > (nhist-1)) minBin=nhist-1;
            maxBin=bin +  deltaBin;
            if (maxBin > (nhist-1)) maxBin=nhist-1;
            for(int k=minBin;k<maxBin+1;k+=1) {
              invNormKernel=invNormConstantBaseAB/vectorX2[k];
              gofrAB[k] += kernel(vectorX[k]-distanceModulo, dfunc)/2.;
              if (!doNotCalculateDerivatives()) {
                 Vector value = dfunc * distance_versor;
                 gofrPrimeAB[k][i0] += value;
                 //gofrPrimeAB[k][i1] -= value;
                 Tensor vv(value/2., distance);
                 gofrVirialAB[k] += vv;
              }      
            }
          }
       }
    }
    // Loop over B atoms
    for(unsigned int i=0;i<nlBA->getNumberOfLocalAtoms();i++) {
       std::vector<unsigned> neighbors;
       unsigned index=nlBA->getIndexOfLocalAtom(i);
       neighbors=nlBA->getNeighbors(index);
       // Loop over A type neighbors
       for(unsigned int j=0;j<neighbors.size();j++) {  
          double dfunc, d2;
          Vector distance;
          Vector distance_versor;
          unsigned i0=index+ga_lista.size();
          unsigned i1=neighbors[j]-gb_lista.size();
          if(getAbsoluteIndex(i0)==getAbsoluteIndex(i1)) continue;
          if(pbc){
           distance=pbcDistance(getPosition(i0),getPosition(i1));
          } else {
           distance=delta(getPosition(i0),getPosition(i1));
          }
          if ( (d2=distance[0]*distance[0])<rcut2 && (d2+=distance[1]*distance[1])<rcut2 && (d2+=distance[2]*distance[2])<rcut2) {
            double distanceModulo=std::sqrt(d2);
            Vector distance_versor = distance / distanceModulo;
            unsigned bin=std::floor(distanceModulo/deltar);
            int minBin, maxBin; // These cannot be unsigned
            // Only consider contributions to g(r) of atoms less than n*sigma bins apart from the actual distance
            minBin=bin - deltaBin;
            if (minBin < 0) minBin=0;
            if (minBin > (nhist-1)) minBin=nhist-1;
            maxBin=bin +  deltaBin;
            if (maxBin > (nhist-1)) maxBin=nhist-1;
            for(int k=minBin;k<maxBin+1;k+=1) {
              invNormKernel=invNormConstantBaseAB/vectorX2[k];
              gofrAB[k] += kernel(vectorX[k]-distanceModulo, dfunc)/2.;
              if (!doNotCalculateDerivatives()) {
                 Vector value = dfunc * distance_versor;
                 gofrPrimeAB[k][i0] += value;
                 //gofrPrimeAB[k][i1] -= value;
                 Tensor vv(value/2., distance);
                 gofrVirialAB[k] += vv;
              }      
            }
          }
       }
    }
  } else if (!doneigh && doLowComm) {
     // Loop over pairs
     for(unsigned int i=rank;i<getNumberOfAtoms();i+=stride) {
        for(unsigned int j=0;j<getNumberOfAtoms();j+=1) {
           double dfunc, d2;
           Vector distance;
           Vector distance_versor;
           if(getAbsoluteIndex(i)==getAbsoluteIndex(j)) continue;
           if(pbc){
            distance=pbcDistance(getPosition(i),getPosition(j));
           } else {
            distance=delta(getPosition(i),getPosition(j));
           }
           if ( (d2=distance[0]*distance[0])<rcut2 && (d2+=distance[1]*distance[1])<rcut2 && (d2+=distance[2]*distance[2])<rcut2) {
             double distanceModulo=std::sqrt(d2);
             Vector distance_versor = distance / distanceModulo;
             unsigned bin=std::floor(distanceModulo/deltar);
             int minBin, maxBin; // These cannot be unsigned
             // Only consider contributions to g(r) of atoms less than n*sigma bins apart from the actual distance
             minBin=bin - deltaBin;
             if (minBin < 0) minBin=0;
             if (minBin > (nhist-1)) minBin=nhist-1;
             maxBin=bin +  deltaBin;
             if (maxBin > (nhist-1)) maxBin=nhist-1;
             //if (i==200 && j<numberOfAatoms) std::cout << "NO: " << j << "\n";
             for(int k=minBin;k<maxBin+1;k+=1) {
               // To which gofr does this pair of atoms contribute?
               if (i<numberOfAatoms && j<numberOfAatoms) {
                 if (!do_ignore_aa) {
                    // AA case
                    invNormKernel=invNormConstantBaseAA/vectorX2[k];
                    gofrAA[k] += kernel(vectorX[k]-distanceModulo, dfunc)/2.;
                    if (!doNotCalculateDerivatives()) {
                       Vector value = dfunc * distance_versor;
                       gofrPrimeAA[k][i] += value;
                       //gofrPrimeAA[k][j] -= value;
                       Tensor vv(value/2., distance);
                       gofrVirialAA[k] += vv;
                    }
                 }
               } else if (i>=numberOfAatoms && j>=numberOfAatoms) {
                    if (!do_ignore_bb) {
                       // BB case
                       invNormKernel=invNormConstantBaseBB/vectorX2[k];
                       gofrBB[k] += kernel(vectorX[k]-distanceModulo, dfunc)/2.;
                       if (!doNotCalculateDerivatives()) {
                          Vector value = dfunc * distance_versor;
                          gofrPrimeBB[k][i] += value;
                          //gofrPrimeBB[k][j] -= value;
                          Tensor vv(value/2., distance);
                          gofrVirialBB[k] += vv;
                       }
                    }
               } else {
                    // AB or BA case
                    invNormKernel=invNormConstantBaseAB/vectorX2[k];
                    gofrAB[k] += kernel(vectorX[k]-distanceModulo, dfunc)/2.;
                    if (!doNotCalculateDerivatives()) {
                       Vector value = dfunc * distance_versor;
                       gofrPrimeAB[k][i] += value;
                       //gofrPrimeAB[k][j] -= value;
                       Tensor vv(value/2., distance);
                       gofrVirialAB[k] += vv;
                    }
               }
             }
           }
        }
     }
  }
  if(!serial){
    if (!do_ignore_aa) comm.Sum(gofrAA);
    if (!do_ignore_bb) comm.Sum(gofrBB);
    comm.Sum(gofrAB);
    if (!doNotCalculateDerivatives()) {
       if (!doLowComm) {
         if (!do_ignore_aa) comm.Sum(gofrPrimeAA);
         if (!do_ignore_bb) comm.Sum(gofrPrimeBB);
         comm.Sum(gofrPrimeAB);
       }
       if (!do_ignore_aa) comm.Sum(gofrVirialAA);
       if (!do_ignore_bb) comm.Sum(gofrVirialBB);
       comm.Sum(gofrVirialAB);
    }
  }
  /*
  for(unsigned j=0;j<nhist;++j){
    double x=deltar*(j+0.5);
    double normConstantAA = normConstantBaseAA*x*x;
    double normConstantAB = normConstantBaseAB*x*x;
    double normConstantBB = normConstantBaseBB*x*x;
    gofrAA[j] /= normConstantAA;
    gofrAB[j] /= normConstantAB;
    if (!do_ignore_bb) gofrBB[j] /= normConstantBB;
    if (!doNotCalculateDerivatives()) {
       gofrVirialAA[j] /= normConstantAA;
       gofrVirialAB[j] /= normConstantAB;
       if (!do_ignore_bb) gofrVirialBB[j] /= normConstantBB;
       for(unsigned k=0;k<getNumberOfAtoms();++k){
         gofrPrimeAA[j][k] /= normConstantAA;
         gofrPrimeAB[j][k] /= normConstantAB;
         if (!do_ignore_bb) gofrPrimeBB[j][k] /= normConstantBB;
       }
    }
  }
  */
  // Average g(r)s
  if (doAverageGofr) {
     if (!doNotCalculateDerivatives()) error("Cannot calculate derivatives or bias using the AVERAGE_GOFR option");
     double factor;
     if (averageGofrTau==0 || iteration < averageGofrTau) {
        iteration += 1;
        factor = 1./( (double) iteration );
     } else factor = 2./((double) averageGofrTau + 1.);
     for(unsigned i=0;i<nhist;++i){
        avgGofrAA[i] += (gofrAA[i]-avgGofrAA[i])*factor;
        gofrAA[i] = avgGofrAA[i];
        avgGofrAB[i] += (gofrAB[i]-avgGofrAB[i])*factor;
        gofrAB[i] = avgGofrAB[i];
        avgGofrBB[i] += (gofrBB[i]-avgGofrBB[i])*factor;
        gofrBB[i] = avgGofrBB[i];
     }
  }
  // Output of gofrs
  if (doOutputGofr && (getStep()%outputStride==0)) outputGofr(gofrAA,gofrAB,gofrBB);
  // Construct integrands
  vector<double> integrandAA(nhist);
  vector<double> integrandAB(nhist);
  vector<double> integrandBB(nhist);
  vector<double> logGofrAAx2(nhist);
  vector<double> logGofrABx2(nhist);
  vector<double> logGofrBBx2(nhist);
  for(unsigned j=0;j<nhist;++j){
    logGofrAAx2[j] = std::log(gofrAA[j])*vectorX2[j];
    logGofrABx2[j] = std::log(gofrAB[j])*vectorX2[j];
    logGofrBBx2[j] = std::log(gofrBB[j])*vectorX2[j];
    if (!do_ignore_aa) {
       if (gofrAA[j]<1.e-10) {
         integrandAA[j] = vectorX2[j];
       } else {
         integrandAA[j] = (gofrAA[j]*logGofrAAx2[j])+(-gofrAA[j]+1)*vectorX2[j];
       }
    }
    if (gofrAB[j]<1.e-10) {
      integrandAB[j] = vectorX2[j];
    } else {
      integrandAB[j] = (gofrAB[j]*logGofrABx2[j])+(-gofrAB[j]+1)*vectorX2[j];
    }
    if (!do_ignore_bb) {
       if (gofrBB[j]<1.e-10) {
         integrandBB[j] = vectorX2[j];
       } else {
         integrandBB[j] = (gofrBB[j]*logGofrBBx2[j])+(-gofrBB[j]+1)*vectorX2[j];
       }
    }
  }
  // Output of integrands
  if (doOutputIntegrand && (getStep()%outputStride==0)) outputIntegrand(integrandAA,integrandAB,integrandBB);
  // Integrate to obtain pair entropy
  double prefactorAA = -2*pi*(densityA*densityA/density);
  double prefactorAB = -4*pi*(densityA*densityB/density);
  double prefactorBB = -2*pi*(densityB*densityB/density);
  double pairAAvalue;
  if (!do_ignore_aa) pairAAvalue =  prefactorAA*integrate(integrandAA,deltar);
  else pairAAvalue = 0.;
  double pairBBvalue;
  if (!do_ignore_bb) pairBBvalue = prefactorBB*integrate(integrandBB,deltar);
  else pairBBvalue = 0.;
  double pairABvalue = prefactorAB*integrate(integrandAB,deltar);
  // Output individual pairs or only full pair entropy
  if (do_pairs) {
    Value* pairAA=getPntrToComponent("pairAA");
    Value* pairAB=getPntrToComponent("pairAB");
    Value* pairBB=getPntrToComponent("pairBB");
    Value* full=getPntrToComponent("full");
    pairAA->set(pairAAvalue);
    pairAB->set(pairABvalue);
    pairBB->set(pairBBvalue);
    full->set(pairAAvalue+pairABvalue+pairBBvalue);
  } else {
    setValue           (pairAAvalue+pairABvalue+pairBBvalue);
  } 
  if (!doNotCalculateDerivatives() ) {
    if (doLowComm && doneigh) {
      if (!do_ignore_aa) {
        for(unsigned int i=0;i<nlAA->getNumberOfLocalAtoms();i++) {
          unsigned index=nlAA->getIndexOfLocalAtom(i);
          vector<Vector> integrandDerivativesAA(nhist);
          for(unsigned k=0;k<nhist;++k){
            if (gofrAA[k]>1.e-10) { integrandDerivativesAA[k] = gofrPrimeAA[k][index]*logGofrAAx2[k]; }
          }
          derivAA[index] =  prefactorAA*integrate(integrandDerivativesAA,deltar);
          //log.printf("%f %f %f \n",gofrPrimeAA[k][index],derivAA[index]);
        }  
      }
      if (!do_ignore_bb) {
        for(unsigned int i=0;i<nlBB->getNumberOfLocalAtoms();i++) {
          unsigned index=nlBB->getIndexOfLocalAtom(i)+ga_lista.size();
          vector<Vector> integrandDerivativesBB(nhist);
          for(unsigned k=0;k<nhist;++k){
            if (gofrBB[k]>1.e-10) { integrandDerivativesBB[k] = gofrPrimeBB[k][index]*logGofrBBx2[k]; }
          }
          derivBB[index] =  prefactorBB*integrate(integrandDerivativesBB,deltar);
        }  
      }
      for(unsigned int i=0;i<nlAB->getNumberOfLocalAtoms();i++) {
        unsigned index=nlAB->getIndexOfLocalAtom(i);
        vector<Vector> integrandDerivativesAB(nhist);
        for(unsigned k=0;k<nhist;++k){
          if (gofrAB[k]>1.e-10) { integrandDerivativesAB[k] = gofrPrimeAB[k][index]*logGofrABx2[k]; }
        }
        derivAB[index] =  prefactorAB*integrate(integrandDerivativesAB,deltar);
      }  
      for(unsigned int i=0;i<nlBA->getNumberOfLocalAtoms();i++) {
        unsigned index=nlBA->getIndexOfLocalAtom(i)+ga_lista.size();
        vector<Vector> integrandDerivativesAB(nhist);
        for(unsigned k=0;k<nhist;++k){
          if (gofrAB[k]>1.e-10) { integrandDerivativesAB[k] = gofrPrimeAB[k][index]*logGofrABx2[k]; }
        }
        derivAB[index] =  prefactorAB*integrate(integrandDerivativesAB,deltar);
      }  
    } else {
      // Construct integrand and integrate derivatives
      for(unsigned int j=rank;j<getNumberOfAtoms();j+=stride) {
      //for(unsigned j=0;j<getNumberOfAtoms();++j) {
        vector<Vector> integrandDerivativesAA(nhist);
        vector<Vector> integrandDerivativesAB(nhist);
        vector<Vector> integrandDerivativesBB(nhist);
        for(unsigned k=0;k<nhist;++k){
          if (!do_ignore_aa && gofrAA[k]>1.e-10) { integrandDerivativesAA[k] = gofrPrimeAA[k][j]*logGofrAAx2[k]; }
          if (gofrAB[k]>1.e-10) { integrandDerivativesAB[k] = gofrPrimeAB[k][j]*logGofrABx2[k]; }
          if (!do_ignore_bb && gofrBB[k]>1.e-10) { integrandDerivativesBB[k] = gofrPrimeBB[k][j]*logGofrBBx2[k]; }
        }
        if (!do_ignore_aa) derivAA[j] =  prefactorAA*integrate(integrandDerivativesAA,deltar);
        derivAB[j] =  prefactorAB*integrate(integrandDerivativesAB,deltar);
        if (!do_ignore_bb) derivBB[j] =  prefactorBB*integrate(integrandDerivativesBB,deltar);
      }
    }
    if(!serial){
       if (!do_ignore_aa) comm.Sum(derivAA);
       comm.Sum(derivAB);
       if (!do_ignore_bb) comm.Sum(derivBB);
    }
    if (do_pairs) {
      Value* pairAA=getPntrToComponent("pairAA");
      Value* pairAB=getPntrToComponent("pairAB");
      Value* pairBB=getPntrToComponent("pairBB");
      Value* full=getPntrToComponent("full");
      for(unsigned j=0;j<getNumberOfAtoms();++j) setAtomsDerivatives (pairAA,j,derivAA[j]);
      for(unsigned j=0;j<getNumberOfAtoms();++j) setAtomsDerivatives (pairAB,j,derivAB[j]);
      for(unsigned j=0;j<getNumberOfAtoms();++j) setAtomsDerivatives (pairBB,j,derivBB[j]);
      for(unsigned j=0;j<getNumberOfAtoms();++j) setAtomsDerivatives (full,j,derivAA[j]+derivAB[j]+derivBB[j]);
    } else {
      for(unsigned j=0;j<getNumberOfAtoms();++j) setAtomsDerivatives (j,derivAA[j]+derivAB[j]+derivBB[j]);
    }
    // Virial of positions
    // Construct virial integrand
    vector<Tensor> integrandVirialAA(nhist);
    vector<Tensor> integrandVirialAB(nhist);
    vector<Tensor> integrandVirialBB(nhist);
    for(unsigned j=0;j<nhist;++j){
      if (!do_ignore_aa && gofrAA[j]>1.e-10) { integrandVirialAA[j] = gofrVirialAA[j]*logGofrAAx2[j];}
      if (gofrAB[j]>1.e-10) { integrandVirialAB[j] = gofrVirialAB[j]*logGofrABx2[j];}
      if (!do_ignore_bb && gofrBB[j]>1.e-10) { integrandVirialBB[j] = gofrVirialBB[j]*logGofrBBx2[j];}
    }
    // Integrate virial
    Tensor virialAA;
    Tensor virialAB = prefactorAB*integrate(integrandVirialAB,deltar);
    Tensor virialBB;
    if (!do_ignore_aa) virialAA = prefactorAA*integrate(integrandVirialAA,deltar);
    if (!do_ignore_bb) virialBB = prefactorBB*integrate(integrandVirialBB,deltar);
    // Virial of volume
    // Construct virial integrand
    vector<double> integrandVirialVolumeAA(nhist);
    vector<double> integrandVirialVolumeAB(nhist);
    vector<double> integrandVirialVolumeBB(nhist);
    for(unsigned j=0;j<nhist;j+=1) {
      if (!do_ignore_aa) integrandVirialVolumeAA[j] = (-gofrAA[j]+1)*vectorX2[j];
      integrandVirialVolumeAB[j] = (-gofrAB[j]+1)*vectorX2[j];
      if (!do_ignore_bb) integrandVirialVolumeBB[j] = (-gofrBB[j]+1)*vectorX2[j];
    }
    // Integrate virial
    if (!do_ignore_aa) virialAA += prefactorAA*integrate(integrandVirialVolumeAA,deltar)*Tensor::identity();
    virialAB += prefactorAB*integrate(integrandVirialVolumeAB,deltar)*Tensor::identity();
    if (!do_ignore_bb) virialBB += prefactorBB*integrate(integrandVirialVolumeBB,deltar)*Tensor::identity();
    // Set virial
    if (do_pairs) {
      Value* pairAA=getPntrToComponent("pairAA");
      Value* pairAB=getPntrToComponent("pairAB");
      Value* pairBB=getPntrToComponent("pairBB");
      Value* full=getPntrToComponent("full");
      setBoxDerivatives  (pairAA,virialAA);
      setBoxDerivatives  (pairAB,virialAB);
      setBoxDerivatives  (pairBB,virialBB);
      setBoxDerivatives  (full,virialAA+virialAB+virialBB);
    } else {
      setBoxDerivatives  (virialAA+virialAB+virialBB);
    }
  }
}

double PairEntropyMulticomp::kernel(double distance,double&der)const{
  // Gaussian function and derivative
  //double result = invSqrt2piSigma*std::exp(-distance*distance/sigmaSqr2) ;
  double result = invNormKernel*std::exp(-distance*distance/sigmaSqr2) ;
  der = -distance*result/sigmaSqr;
  return result;
}

double PairEntropyMulticomp::integrate(vector<double> integrand, double delta)const{
  // Trapezoid rule
  double result = 0.;
  for(unsigned i=1;i<(integrand.size()-1);++i){
    result += integrand[i];
  }
  result += 0.5*integrand[0];
  result += 0.5*integrand[integrand.size()-1];
  result *= delta;
  return result;
}

Vector PairEntropyMulticomp::integrate(vector<Vector> integrand, double delta)const{
  // Trapezoid rule
  Vector result;
  for(unsigned i=1;i<(integrand.size()-1);++i){
      result += integrand[i];
  }
  result += 0.5*integrand[0];
  result += 0.5*integrand[integrand.size()-1];
  result *= delta;
  return result;
}

Tensor PairEntropyMulticomp::integrate(vector<Tensor> integrand, double delta)const{
  // Trapezoid rule
  Tensor result;
  for(unsigned i=1;i<(integrand.size()-1);++i){
      result += integrand[i];
  }
  result += 0.5*integrand[0];
  result += 0.5*integrand[integrand.size()-1];
  result *= delta;
  return result;
}

void PairEntropyMulticomp::outputGofr(vector<double> gofrAA, vector<double> gofrAB, vector<double> gofrBB) {
  for(unsigned i=0;i<gofrAA.size();++i){
     gofrOfile.printField("r",vectorX[i]).printField("gofrAA",gofrAA[i]).printField("gofrAB",gofrAB[i]).printField("gofrBB",gofrBB[i]).printField();
  }
  gofrOfile.printf("\n");
  gofrOfile.printf("\n");
}

void PairEntropyMulticomp::outputIntegrand(vector<double> gofrAA, vector<double> gofrAB, vector<double> gofrBB) {
  for(unsigned i=0;i<gofrAA.size();++i){
     integrandOfile.printField("r",vectorX[i]).printField("integrandAA",gofrAA[i]).printField("integrandAB",gofrAB[i]).printField("integrandBB",gofrBB[i]).printField();
  }
  integrandOfile.printf("\n");
  integrandOfile.printf("\n");
}

}
}
src/colvar/PairOrientationalEntropy.cpp0000777000175000017500000012514613777445145017663 0ustar  maplemaple/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   Copyright (c) 2011-2016 The plumed team
   (see the PEOPLE file at the root of the distribution for a list of names)

   See http://www.plumed.org for more information.

   This file is part of plumed, version 2.

   plumed is free software: you can redistribute it and/or modify
   it under the terms of the GNU Lesser General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   plumed is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public License
   along with plumed.  If not, see <http://www.gnu.org/licenses/>.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
#include "Colvar.h"
#include "ActionRegister.h"
#include "tools/NeighborListParallel.h"
#include "tools/Communicator.h"
#include "tools/Tools.h"
#include "tools/IFile.h"

#include <string>
#include <math.h>

using namespace std;

namespace PLMD{
namespace colvar{

//+PLUMEDOC COLVAR PAIRENTROPY
/*
Calculate the global pair entropy using the expression:
\f[
s=-2\pi\rho k_B \int\limits_0^{r_{\mathrm{max}}} \left [ g(r) \ln g(r) - g(r) + 1 \right ] r^2 dr .
\f]
where \f$ g(r) $\f is the pair distribution function and \f$ r_{\mathrm{max}} $\f is a cutoff in the integration (MAXR).
For the integration the interval from 0 to  \f$ r_{\mathrm{max}} $\f is partitioned in NHIST equal intervals. 
To make the calculation of \f$ g(r) $\f differentiable, the following function is used:
\f[
g(r) = \frac{1}{4 \pi \rho r^2} \sum\limits_{j} \frac{1}{\sqrt{2 \pi \sigma^2}} e^{-(r-r_{ij})^2/(2\sigma^2)} ,
\f]
where \f$ \rho $\f is the density and \f$ sigma $\f is a broadening parameter (SIGMA).  
\par Example)
The following input tells plumed to calculate the pair entropy of atoms 1-250 with themselves.
\verbatim
PAIRENTROPY ...
 LABEL=s2
 GROUPA=1-250
 MAXR=0.65
 SIGMA=0.025
 NHIST=100
 NLIST
 NL_CUTOFF=0.75
 NL_STRIDE=10
... PAIRENTROPY
\endverbatim
*/
//+ENDPLUMEDOC

class PairOrientationalEntropy : public Colvar {
  bool pbc, serial, invalidateList, firsttime, doneigh;
  NeighborListParallel *nl;
  vector<AtomNumber> center_lista,start_lista,end_lista;
  std::vector<PLMD::AtomNumber> atomsToRequest;
  double maxr;
  vector<int> nhist_;
  int nhist1_nhist2_;
  vector<double> sigma_;
  double rcut2;
  double invTwoPiSigma1Sigma2, sigma1Sqr, sigma2Sqr, twoSigma1Sqr,twoSigma2Sqr;
  double deltar, deltaAngle, deltaCosAngle;
  unsigned deltaBin, deltaBinAngle;
  // Integration routines
  double integrate(Matrix<double> integrand, vector<double> delta)const;
  Vector integrate(Matrix<Vector> integrand, vector<double> delta)const;
  Tensor integrate(Matrix<Tensor> integrand, vector<double> delta)const;
  vector<double> x1, x2, x1sqr, x2sqr;
  // Kernel to calculate g(r)
  double kernel(vector<double> distance, double invNormKernel, vector<double>&der)const;
  // Output gofr and integrand
  void outputGofr(Matrix<double> gofr, const char* fileName);
  void outputIntegrand(vector<double> integrand);
  int outputStride;
  bool doOutputGofr, doOutputIntegrand;
  mutable PLMD::OFile gofrOfile;
  // Reference g(r)
  bool doReferenceGofr;
  Matrix<double> referenceGofr;
  double epsilon;
  double densityReference;
  // Average gofr
  Matrix<double> avgGofr;
  unsigned iteration;
  bool doAverageGofr;
  unsigned averageGofrTau;
  // Up-down symmetry
  bool doUpDownSymmetry;
  double startCosAngle;
  // Low communication variant
  bool doLowComm;
public:
  explicit PairOrientationalEntropy(const ActionOptions&);
  ~PairOrientationalEntropy();
  virtual void calculate();
  virtual void prepare();
  static void registerKeywords( Keywords& keys );
};

PLUMED_REGISTER_ACTION(PairOrientationalEntropy,"PAIR_ORIENTATIONAL_ENTROPY")

void PairOrientationalEntropy::registerKeywords( Keywords& keys ){
  Colvar::registerKeywords(keys);
  keys.addFlag("SERIAL",false,"Perform the calculation in serial - for debug purpose");
  keys.addFlag("NLIST",false,"Use a neighbour list to speed up the calculation");
  keys.addFlag("OUTPUT_GOFR",false,"Output g(r)");
  keys.addFlag("AVERAGE_GOFR",false,"Average g(r) over time");
  keys.add("optional","AVERAGE_GOFR_TAU","Characteristic length of a window in which to average the g(r). It is in units of iterations and should be an integer. Zero corresponds to an normal average (infinite window).");
  keys.addFlag("UP_DOWN_SYMMETRY",false,"The symmetry is such that parallel and antiparallel vectors are not distinguished. The angle goes from 0 to pi/2 instead of from 0 to pi.");
  keys.add("optional","OUTPUT_STRIDE","The frequency with which the output is written to files");
  keys.addFlag("OUTPUT_INTEGRAND",false,"Output integrand");
  keys.add("optional","NL_CUTOFF","The cutoff for the neighbour list");
  keys.add("optional","NL_STRIDE","The frequency with which we are updating the atoms in the neighbour list");
  keys.add("atoms","ORIGIN","Define an atom that represents the origin from which to calculate the g(r,theta)");
  keys.add("atoms","CENTER","Center atoms");
  keys.add("atoms","START","Start point of vector defining orientation");
  keys.add("atoms","END","End point of vector defining orientation");
  keys.add("compulsory","MAXR","1","Maximum distance for the radial distribution function ");
  keys.add("optional","NHIST","Number of bins in the rdf ");
  keys.add("compulsory","SIGMA","0.1","Width of gaussians ");
  keys.add("optional","REFERENCE_GOFR_FNAME","the name of the file with the reference g(r)");
  keys.add("optional","REFERENCE_DENSITY","Density to be used with the reference g(r). If not specified or less than 0, the current density is used. Using the current density might lead in large changes of the box volume.");
  keys.addFlag("LOW_COMM",false,"Use an algorithm with less communication between processors");
}

PairOrientationalEntropy::PairOrientationalEntropy(const ActionOptions&ao):
PLUMED_COLVAR_INIT(ao),
pbc(true),
serial(false),
invalidateList(true),
firsttime(true)
{

  parseFlag("SERIAL",serial);

  parseAtomList("CENTER",center_lista);
  parseAtomList("START",start_lista);
  parseAtomList("END",end_lista);
  if(center_lista.size()!=start_lista.size()) error("Number of atoms in START must be equal to the number of atoms in CENTER");
  if(center_lista.size()!=end_lista.size()) error("Number of atoms in START must be equal to the number of atoms in CENTER");

  bool nopbc=!pbc;
  pbc=!nopbc;

// neighbor list stuff
  doneigh=false;
  bool nl_full_list=false;
  double nl_cut=0.0;
  double nl_skin;
  int nl_st=-1;
  parseFlag("NLIST",doneigh);
  if(doneigh){
   parse("NL_CUTOFF",nl_cut);
   if(nl_cut<=0.0) error("NL_CUTOFF should be explicitly specified and positive");
   parse("NL_STRIDE",nl_st);
   //if(nl_st<=0) error("NL_STRIDE should be explicitly specified and positive");
  }

  if(pbc) log.printf("  using periodic boundary conditions\n");
  else    log.printf("  without periodic boundary conditions\n");

  addValueWithDerivatives(); setNotPeriodic();

  parse("MAXR",maxr);
  log.printf("  Integration in the interval from 0. to %f \n", maxr );

  parseVector("SIGMA",sigma_);
  if(sigma_.size() != 2) error("SIGMA keyword takes two input values");
  log.printf("  The pair distribution function is calculated with a Gaussian kernel with deviations %f and %f \n", sigma_[0], sigma_[1]);
  double rcut = maxr + 2*sigma_[0];  // 2*sigma is hard coded
  rcut2 = rcut*rcut;
  if(doneigh){
    if(nl_cut<rcut) error("NL_CUTOFF should be larger than MAXR + 2*SIGMA");
    nl_skin=nl_cut-rcut;
  }

  doUpDownSymmetry=false;
  parseFlag("UP_DOWN_SYMMETRY",doUpDownSymmetry);
  if (doUpDownSymmetry) log.printf("  The angle can take values between 0 and pi/2 due to the up down symmetry. \n");

  parseVector("NHIST",nhist_);
  if (nhist_.size()<1) {
     nhist_.resize(2);
     // Default values
     nhist_[0]=ceil(maxr/sigma_[0]) + 1; 
     if (doUpDownSymmetry) nhist_[1]=ceil(1./sigma_[1]) + 1;
     else nhist_[1]=ceil(2./sigma_[1]) + 1;
  }
  if(nhist_.size() != 2) error("NHIST keyword takes two input values");
  nhist1_nhist2_=nhist_[0]*nhist_[1];
  log.printf("  The r-theta space is discretized using a grid of size %u times %u. \n", nhist_[0], nhist_[1] );
  log.printf("  The integration is performed with the trapezoid rule. \n");

  doOutputGofr=false;
  parseFlag("OUTPUT_GOFR",doOutputGofr);
  if (doOutputGofr) { 
     log.printf("  The g(r) will be written to a file \n");
     gofrOfile.link(*this);
     gofrOfile.open("gofr.txt");
  }
  doOutputIntegrand=false;
  parseFlag("OUTPUT_INTEGRAND",doOutputIntegrand);
  if (doOutputIntegrand) {
     log.printf("  The integrand will be written to a file \n");
  }
  outputStride=1;
  parse("OUTPUT_STRIDE",outputStride);
  if (outputStride!=1 && !doOutputGofr && !doOutputIntegrand) error("Cannot specify OUTPUT_STRIDE if OUTPUT_GOFR or OUTPUT_INTEGRAND not used");
  if (outputStride<1) error("The output stride specified with OUTPUT_STRIDE must be greater than or equal to one.");
  if (outputStride>1) log.printf("  The output stride to write g(r) or the integrand is %d \n", outputStride);

  densityReference=-1.;
  parse("REFERENCE_DENSITY",densityReference);
  if (densityReference>0) log.printf("  Using a density reference of %f .\n", densityReference);

  doReferenceGofr=false;
  std::string referenceGofrFileName;
  parse("REFERENCE_GOFR_FNAME",referenceGofrFileName); 
  if (!referenceGofrFileName.empty() ) {
    epsilon=1.e-8;
    log.printf("  Reading a reference g(r) from the file %s . \n", referenceGofrFileName.c_str() );
    doReferenceGofr=true;
    IFile ifile; 
    ifile.link(*this);
    ifile.open(referenceGofrFileName);
    referenceGofr.resize(nhist_[0],nhist_[1]);
    for(unsigned int i=0;i<nhist_[0];i++) {
       for(unsigned int j=0;j<nhist_[1];j++) {
       double tmp_r, tmp_theta;
       ifile.scanField("r",tmp_r).scanField("theta",tmp_theta).scanField("gofr",referenceGofr[i][j]).scanField();
       }
    }
    //if (densityReference<0) error("REFERENCE_GOFR_DENSITY not given or negative. Please specify a positive REFERENCE_GOFR_DENSITY");
  }

  doAverageGofr=false;
  parseFlag("AVERAGE_GOFR",doAverageGofr);
  if (doAverageGofr) {
     iteration = 1;
     avgGofr.resize(nhist_[0],nhist_[1]);
  }
  averageGofrTau=0;
  parse("AVERAGE_GOFR_TAU",averageGofrTau);
  if (averageGofrTau!=0 && !doAverageGofr) error("AVERAGE_GOFR_TAU specified but AVERAGE_GOFR not given. Specify AVERAGE_GOFR or remove AVERAGE_GOFR_TAU");
  if (doAverageGofr && averageGofrTau==0) log.printf("The g(r) will be averaged over all frames \n");
  if (doAverageGofr && averageGofrTau!=0) log.printf("The g(r) will be averaged with a window of %d steps \n", averageGofrTau);



  doLowComm=false;
  parseFlag("LOW_COMM",doLowComm);
  if (doLowComm) {
     log.printf("  Using the low communication variant of the algorithm");
     nl_full_list=true;
  }

  checkRead();

  // Neighbor lists
  if (doneigh) {
    nl= new NeighborListParallel(center_lista,pbc,getPbc(),comm,log,nl_cut,nl_full_list,nl_st,nl_skin);
    log.printf("  using neighbor lists with\n");
    log.printf("  cutoff %f, and skin %f\n",nl_cut,nl_skin);
    if(nl_st>=0){
      log.printf("  update every %d steps\n",nl_st);
    } else {
      log.printf("  checking every step for dangerous builds and rebuilding as needed\n");
    }
  }
  atomsToRequest.reserve ( center_lista.size() + start_lista.size() + end_lista.size() );
  atomsToRequest.insert (atomsToRequest.end(), center_lista.begin(), center_lista.end() );
  atomsToRequest.insert (atomsToRequest.end(), start_lista.begin(), start_lista.end() );
  atomsToRequest.insert (atomsToRequest.end(), end_lista.begin(), end_lista.end() );
  requestAtoms(atomsToRequest);

  // Define heavily used expressions
  invTwoPiSigma1Sigma2 = (1./(2.*pi*sigma_[0]*sigma_[1]));
  sigma1Sqr = sigma_[0]*sigma_[0];
  sigma2Sqr = sigma_[1]*sigma_[1];
  twoSigma1Sqr = 2*sigma_[0]*sigma_[0];
  twoSigma2Sqr = 2*sigma_[1]*sigma_[1];
  deltar=maxr/(nhist_[0]-1);
  if (!doUpDownSymmetry) {
     deltaCosAngle=2./(nhist_[1]-1);
     startCosAngle=-1.;
  }
  else {
     deltaCosAngle=1./(nhist_[1]-1);
     startCosAngle=0.;
  }
  deltaBin = std::floor(2*sigma_[0]/deltar); // 2*sigma is hard coded
  deltaBinAngle = std::floor(2*sigma_[1]/deltaCosAngle); // 2*sigma is hard coded

  x1.resize(nhist_[0]);
  x1sqr.resize(nhist_[0]);
  x2.resize(nhist_[1]);
  x2sqr.resize(nhist_[1]);
  for(unsigned i=0;i<nhist_[0];++i){
     x1[i]=deltar*i;
     x1sqr[i]=x1[i]*x1[i];
  }
  for(unsigned i=0;i<nhist_[1];++i){
     x2[i]=startCosAngle+deltaCosAngle*i;
     x2sqr[i]=x2[i]*x2[i];
  }
}

PairOrientationalEntropy::~PairOrientationalEntropy(){
  if (doneigh) {
     nl->printStats();
     delete nl;
  }
  if (doOutputGofr) gofrOfile.close();
}

void PairOrientationalEntropy::prepare(){
  if(doneigh && nl->getStride()>0){
    if(firsttime) {
      invalidateList=true;
      firsttime=false;
    } else if ( (nl->getStride()>=0) &&  (getStep()%nl->getStride()==0) ){
      invalidateList=true;
    } else if ( (nl->getStride()<0) && !(nl->isListStillGood(getPositions())) ){
      invalidateList=true;
    } else {
      invalidateList=false;
    }
  }
}

// calculator
void PairOrientationalEntropy::calculate()
{
  //clock_t begin_time = clock();
  // Define intermediate quantities
  Matrix<double> gofr(nhist_[0],nhist_[1]);
  vector<Vector> gofrPrimeCenter(nhist_[0]*nhist_[1]*center_lista.size());
  vector<Vector> gofrPrimeStart(nhist_[0]*nhist_[1]*center_lista.size());
  vector<Vector> gofrPrimeEnd(nhist_[0]*nhist_[1]*center_lista.size());
  Matrix<Tensor> gofrVirial(nhist_[0],nhist_[1]);
  // Calculate volume and density
  double volume=getBox().determinant();
  double density=center_lista.size()/volume;
  // Normalization of g(r)
  double normConstantBase = 2*pi*center_lista.size()*density;
  normConstantBase /= invTwoPiSigma1Sigma2;
  // Take into account "volume" of angles
  double volumeOfAngles;
  if (!doUpDownSymmetry) volumeOfAngles = 2.;
  else volumeOfAngles = 1.;
  normConstantBase /= volumeOfAngles;
  double invNormConstantBase = 1./normConstantBase;
  // Setup parallelization
  unsigned stride=comm.Get_size();
  unsigned rank=comm.Get_rank();
  if(serial){
    stride=1;
    rank=0;
  }else{
    stride=comm.Get_size();
    rank=comm.Get_rank();
  }
  if (doneigh && doLowComm) {
    if(invalidateList){
      vector<Vector> centerPositions(getPositions().begin(),getPositions().begin() + center_lista.size());
      nl->update(centerPositions);
    }
    for(unsigned int i=0;i<nl->getNumberOfLocalAtoms();i+=1) {
       unsigned index=nl->getIndexOfLocalAtom(i);
       unsigned atom1_mol1=index+center_lista.size();
       unsigned atom2_mol1=index+center_lista.size()+start_lista.size();
       std::vector<unsigned> neighbors=nl->getNeighbors(index);
       Vector position_index=getPosition(index);
       Vector mol_vector1=pbcDistance(getPosition(atom1_mol1),getPosition(atom2_mol1)); 
       double norm_v1 = std::sqrt(mol_vector1[0]*mol_vector1[0]+mol_vector1[1]*mol_vector1[1]+mol_vector1[2]*mol_vector1[2]);
       double inv_v1=1./norm_v1;
       double inv_v1_sqr=inv_v1*inv_v1;
       // Loop over neighbors
       for(unsigned int j=0;j<neighbors.size();j+=1) {  
          unsigned neighbor=neighbors[j];
          if(getAbsoluteIndex(index)==getAbsoluteIndex(neighbor)) continue;
          Vector distance=pbcDistance(position_index,getPosition(neighbor));
          double d2;
          if ( (d2=distance[0]*distance[0])<rcut2 && (d2+=distance[1]*distance[1])<rcut2 && (d2+=distance[2]*distance[2])<rcut2) {
             double distanceModulo=std::sqrt(d2);
             Vector distance_versor = distance / distanceModulo;
             unsigned bin=std::floor(distanceModulo/deltar);
             unsigned atom1_mol2=neighbor+center_lista.size();
             unsigned atom2_mol2=neighbor+center_lista.size()+start_lista.size();
             Vector mol_vector2=pbcDistance(getPosition(atom1_mol2),getPosition(atom2_mol2));
             double norm_v2 = std::sqrt(mol_vector2[0]*mol_vector2[0]+mol_vector2[1]*mol_vector2[1]+mol_vector2[2]*mol_vector2[2]);
             double inv_v2=1./norm_v2;
             double inv_v1_inv_v2=inv_v1*inv_v2;
             double cosAngle=dotProduct(mol_vector1,mol_vector2)*inv_v1*inv_v2;
             Vector der_mol1=mol_vector2*inv_v1_inv_v2-cosAngle*mol_vector1*inv_v1_sqr;
             if (doUpDownSymmetry && cosAngle<0) {
                der_mol1 *= -1.;
             }
             unsigned binAngle;
             if (doUpDownSymmetry && cosAngle<0) {
                binAngle=std::floor((-cosAngle-startCosAngle)/deltaCosAngle);
             } else {
                binAngle=std::floor((cosAngle-startCosAngle)/deltaCosAngle);
             }
             int minBin, maxBin; // These cannot be unsigned
             // Only consider contributions to g(r) of atoms less than n*sigma bins apart from the actual distance
             minBin=bin - deltaBin;
             if (minBin < 0) minBin=0;
             if (minBin > (nhist_[0]-1)) minBin=nhist_[0]-1;
             maxBin=bin +  deltaBin;
             if (maxBin > (nhist_[0]-1)) maxBin=nhist_[0]-1;
             int minBinAngle, maxBinAngle; // These cannot be unsigned
             // Only consider contributions to g(r) of atoms less than n*sigma bins apart from the actual angle
             minBinAngle=binAngle - deltaBinAngle;
             maxBinAngle=binAngle +  deltaBinAngle;
             for(int k=minBin;k<maxBin+1;k+=1) {
               double invNormKernel=invNormConstantBase/x1sqr[k];
               vector<double> pos(2);
               pos[0]=x1[k]-distanceModulo;
               for(int l=minBinAngle;l<maxBinAngle+1;l+=1) {
                  double theta=startCosAngle+deltaCosAngle*l;
                  if (doUpDownSymmetry && cosAngle<0) {
                     pos[1]=theta+cosAngle;
                  } else {
                     pos[1]=theta-cosAngle;
                  }
                  // Include periodic effects
                  int h;
                  if (l<0) {
                     h=-l;
                  } else if (l>(nhist_[1]-1)) {
                     h=2*nhist_[1]-l-2;
                  } else {
                     h=l;
                  }
                  vector<double> dfunc(2);
                  if (l==(nhist_[1]-1) || l==0) {
                     gofr[k][h] += kernel(pos,invNormKernel*2.,dfunc)/2.;
                  } else {
                     gofr[k][h] += kernel(pos,invNormKernel,dfunc)/2.;
                  }
                  Vector value1 = dfunc[0]*distance_versor;
                  Vector value2_mol1 = dfunc[1]*der_mol1;
                  gofrPrimeCenter[index*nhist1_nhist2_+k*nhist_[1]+h] += value1;
                  gofrPrimeStart[index*nhist1_nhist2_+k*nhist_[1]+h] +=  value2_mol1;
                  gofrPrimeEnd[index*nhist1_nhist2_+k*nhist_[1]+h] -=  value2_mol1;
                  Tensor vv1(value1, distance);
                  Tensor vv2_mol1(value2_mol1, mol_vector1);
                  gofrVirial[k][h] += vv1/2.+vv2_mol1;
               }
             }
           }
        }
     }
  } else if (doneigh && !doLowComm) {
    if(invalidateList){
      vector<Vector> centerPositions(getPositions().begin(),getPositions().begin() + center_lista.size());
      nl->update(centerPositions);
    }
    for(unsigned int i=0;i<nl->getNumberOfLocalAtoms();i+=1) {
       unsigned index=nl->getIndexOfLocalAtom(i);
       unsigned atom1_mol1=index+center_lista.size();
       unsigned atom2_mol1=index+center_lista.size()+start_lista.size();
       std::vector<unsigned> neighbors=nl->getNeighbors(index);
       Vector position_index=getPosition(index);
       Vector mol_vector1=pbcDistance(getPosition(atom1_mol1),getPosition(atom2_mol1)); 
       double norm_v1 = std::sqrt(mol_vector1[0]*mol_vector1[0]+mol_vector1[1]*mol_vector1[1]+mol_vector1[2]*mol_vector1[2]);
       double inv_v1=1./norm_v1;
       double inv_v1_sqr=inv_v1*inv_v1;
       // Loop over neighbors
       for(unsigned int j=0;j<neighbors.size();j+=1) {  
          unsigned neighbor=neighbors[j];
          Vector distance=pbcDistance(position_index,getPosition(neighbor));
          double d2;
          if ( (d2=distance[0]*distance[0])<rcut2 && (d2+=distance[1]*distance[1])<rcut2 && (d2+=distance[2]*distance[2])<rcut2) {
             double distanceModulo=std::sqrt(d2);
             Vector distance_versor = distance / distanceModulo;
             unsigned bin=std::floor(distanceModulo/deltar);
             unsigned atom1_mol2=neighbor+center_lista.size();
             unsigned atom2_mol2=neighbor+center_lista.size()+start_lista.size();
             Vector mol_vector2=pbcDistance(getPosition(atom1_mol2),getPosition(atom2_mol2));
             double norm_v2 = std::sqrt(mol_vector2[0]*mol_vector2[0]+mol_vector2[1]*mol_vector2[1]+mol_vector2[2]*mol_vector2[2]);
             double inv_v2=1./norm_v2;
             double inv_v2_sqr=inv_v2*inv_v2;
             double inv_v1_inv_v2=inv_v1*inv_v2;
             double cosAngle=dotProduct(mol_vector1,mol_vector2)*inv_v1*inv_v2;
             Vector der_mol1=mol_vector2*inv_v1_inv_v2-cosAngle*mol_vector1*inv_v1_sqr;
             Vector der_mol2=mol_vector1*inv_v1_inv_v2-cosAngle*mol_vector2*inv_v2_sqr;
             if (doUpDownSymmetry && cosAngle<0) {
                der_mol1 *= -1.;
                der_mol2 *= -1.;
             }
             unsigned binAngle;
             if (doUpDownSymmetry && cosAngle<0) {
                binAngle=std::floor((-cosAngle-startCosAngle)/deltaCosAngle);
             } else {
                binAngle=std::floor((cosAngle-startCosAngle)/deltaCosAngle);
             }
             int minBin, maxBin; // These cannot be unsigned
             // Only consider contributions to g(r) of atoms less than n*sigma bins apart from the actual distance
             minBin=bin - deltaBin;
             if (minBin < 0) minBin=0;
             if (minBin > (nhist_[0]-1)) minBin=nhist_[0]-1;
             maxBin=bin +  deltaBin;
             if (maxBin > (nhist_[0]-1)) maxBin=nhist_[0]-1;
             int minBinAngle, maxBinAngle; // These cannot be unsigned
             // Only consider contributions to g(r) of atoms less than n*sigma bins apart from the actual angle
             minBinAngle=binAngle - deltaBinAngle;
             maxBinAngle=binAngle +  deltaBinAngle;
             for(int k=minBin;k<maxBin+1;k+=1) {
               double invNormKernel=invNormConstantBase/x1sqr[k];
               vector<double> pos(2);
               pos[0]=x1[k]-distanceModulo;
               for(int l=minBinAngle;l<maxBinAngle+1;l+=1) {
                  double theta=startCosAngle+deltaCosAngle*l;
                  if (doUpDownSymmetry && cosAngle<0) {
                     pos[1]=theta+cosAngle;
                  } else {
                     pos[1]=theta-cosAngle;
                  }
                  // Include periodic effects
                  int h;
                  if (l<0) {
                     h=-l;
                  } else if (l>(nhist_[1]-1)) {
                     h=2*nhist_[1]-l-2;
                  } else {
                     h=l;
                  }
                  vector<double> dfunc(2);
                  if (l==(nhist_[1]-1) || l==0) {
                     gofr[k][h] += kernel(pos,2*invNormKernel,dfunc);
                  } else {
                     gofr[k][h] += kernel(pos,invNormKernel,dfunc);
                  }
                  Vector value1 = dfunc[0]*distance_versor;
                  Vector value2_mol1 = dfunc[1]*der_mol1;
                  Vector value2_mol2 = dfunc[1]*der_mol2;

                  gofrPrimeCenter[index*nhist1_nhist2_+k*nhist_[1]+h] += value1;
                  gofrPrimeStart[index*nhist1_nhist2_+k*nhist_[1]+h] +=  value2_mol1;
                  gofrPrimeEnd[index*nhist1_nhist2_+k*nhist_[1]+h] -=  value2_mol1;

                  gofrPrimeCenter[neighbor*nhist1_nhist2_+k*nhist_[1]+h] -= value1;
                  gofrPrimeStart[neighbor*nhist1_nhist2_+k*nhist_[1]+h] +=  value2_mol2;
                  gofrPrimeEnd[neighbor*nhist1_nhist2_+k*nhist_[1]+h] -=  value2_mol2;

                  Tensor vv1(value1, distance);
                  Tensor vv2_mol1(value2_mol1, mol_vector1);
                  Tensor vv2_mol2(value2_mol2, mol_vector2);
                  gofrVirial[k][h] += vv1+vv2_mol1+vv2_mol2;
               }
             }
           }
        }
     }
  } else if (!doneigh && doLowComm) {
    for(unsigned int i=rank;i<center_lista.size();i+=stride) {
      unsigned atom1_mol1=i+center_lista.size();
      unsigned atom2_mol1=i+center_lista.size()+start_lista.size();
      Vector mol_vector1=pbcDistance(getPosition(atom1_mol1),getPosition(atom2_mol1)); 
      double norm_v1 = std::sqrt(mol_vector1[0]*mol_vector1[0]+mol_vector1[1]*mol_vector1[1]+mol_vector1[2]*mol_vector1[2]);
      double inv_v1=1./norm_v1;
      double inv_v1_sqr=inv_v1*inv_v1;
      for(unsigned int j=0;j<center_lista.size();j+=1) {
        double d2;
        Vector distance;
        if(getAbsoluteIndex(i)==getAbsoluteIndex(j)) continue;
        if(pbc){
         distance=pbcDistance(getPosition(i),getPosition(j));
        } else {
         distance=delta(getPosition(i),getPosition(j));
        }
        if ( (d2=distance[0]*distance[0])<rcut2 && (d2+=distance[1]*distance[1])<rcut2 && (d2+=distance[2]*distance[2])<rcut2) {
          double distanceModulo=std::sqrt(d2);
          Vector distance_versor = distance / distanceModulo;
          unsigned bin=std::floor(distanceModulo/deltar);
          unsigned atom1_mol2=j+center_lista.size();
          unsigned atom2_mol2=j+center_lista.size()+start_lista.size();
          Vector mol_vector2=pbcDistance(getPosition(atom1_mol2),getPosition(atom2_mol2));
          double norm_v2 = std::sqrt(mol_vector2[0]*mol_vector2[0]+mol_vector2[1]*mol_vector2[1]+mol_vector2[2]*mol_vector2[2]);
          double inv_v2=1./norm_v2;
          double inv_v1_inv_v2=inv_v1*inv_v2;
          double cosAngle=dotProduct(mol_vector1,mol_vector2)*inv_v1*inv_v2;
          Vector der_mol1=mol_vector2*inv_v1_inv_v2-cosAngle*mol_vector1*inv_v1_sqr;
          if (doUpDownSymmetry && cosAngle<0) {
             der_mol1 *= -1.;
          }
          unsigned binAngle;
          if (doUpDownSymmetry && cosAngle<0) {
             binAngle=std::floor((-cosAngle-startCosAngle)/deltaCosAngle);
          } else {
             binAngle=std::floor((cosAngle-startCosAngle)/deltaCosAngle);
          }
          int minBin, maxBin; // These cannot be unsigned
          // Only consider contributions to g(r) of atoms less than n*sigma bins apart from the actual distance
          minBin=bin - deltaBin;
          if (minBin < 0) minBin=0;
          if (minBin > (nhist_[0]-1)) minBin=nhist_[0]-1;
          maxBin=bin +  deltaBin;
          if (maxBin > (nhist_[0]-1)) maxBin=nhist_[0]-1;
          int minBinAngle, maxBinAngle; // These cannot be unsigned
          // Only consider contributions to g(r) of atoms less than n*sigma bins apart from the actual angle
          minBinAngle=binAngle - deltaBinAngle;
          maxBinAngle=binAngle +  deltaBinAngle;
          for(int k=minBin;k<maxBin+1;k+=1) {
            double invNormKernel=invNormConstantBase/x1sqr[k];
            vector<double> pos(2);
            pos[0]=x1[k]-distanceModulo;
            for(int l=minBinAngle;l<maxBinAngle+1;l+=1) {
               double theta=startCosAngle+deltaCosAngle*l;
               if (doUpDownSymmetry && cosAngle<0) {
                  pos[1]=theta+cosAngle;
               } else {
                  pos[1]=theta-cosAngle;
               }
               // Include periodic effects
               int h;
               if (l<0) {
                  h=-l;
               } else if (l>(nhist_[1]-1)) {
                  h=2*nhist_[1]-l-2;
               } else {
                  h=l;
               }
               vector<double> dfunc(2);
               if (l==(nhist_[1]-1) || l==0) {
                  gofr[k][h] += kernel(pos,2*invNormKernel,dfunc)/2.;
               } else {
                  gofr[k][h] += kernel(pos,invNormKernel,dfunc)/2.;
               }
               Vector value1 = dfunc[0]*distance_versor;
               Vector value2_mol1 = dfunc[1]*der_mol1;

               gofrPrimeCenter[i*nhist1_nhist2_+k*nhist_[1]+h] += value1;
               gofrPrimeStart[i*nhist1_nhist2_+k*nhist_[1]+h] +=  value2_mol1;
               gofrPrimeEnd[i*nhist1_nhist2_+k*nhist_[1]+h] -=  value2_mol1;

               Tensor vv1(value1, distance);
               Tensor vv2_mol1(value2_mol1, mol_vector1);
               gofrVirial[k][h] += vv1/2.+vv2_mol1; //+vv2_mol2;
            }
          }
        }
      }
    }
  } else if (!doneigh && !doLowComm) {
    for(unsigned int i=rank;i<(center_lista.size()-1);i+=stride) {
      unsigned atom1_mol1=i+center_lista.size();
      unsigned atom2_mol1=i+center_lista.size()+start_lista.size();
      Vector mol_vector1=pbcDistance(getPosition(atom1_mol1),getPosition(atom2_mol1)); 
      double norm_v1 = std::sqrt(mol_vector1[0]*mol_vector1[0]+mol_vector1[1]*mol_vector1[1]+mol_vector1[2]*mol_vector1[2]);
      double inv_v1=1./norm_v1;
      double inv_v1_sqr=inv_v1*inv_v1;
      for(unsigned int j=i+1;j<center_lista.size();j+=1) {
        double d2;
        Vector distance;
        if(getAbsoluteIndex(i)==getAbsoluteIndex(j)) continue;
        if(pbc){
         distance=pbcDistance(getPosition(i),getPosition(j));
        } else {
         distance=delta(getPosition(i),getPosition(j));
        }
        if ( (d2=distance[0]*distance[0])<rcut2 && (d2+=distance[1]*distance[1])<rcut2 && (d2+=distance[2]*distance[2])<rcut2) {
          double distanceModulo=std::sqrt(d2);
          Vector distance_versor = distance / distanceModulo;
          unsigned bin=std::floor(distanceModulo/deltar);
          unsigned atom1_mol2=j+center_lista.size();
          unsigned atom2_mol2=j+center_lista.size()+start_lista.size();
          Vector mol_vector2=pbcDistance(getPosition(atom1_mol2),getPosition(atom2_mol2));
          double norm_v2 = std::sqrt(mol_vector2[0]*mol_vector2[0]+mol_vector2[1]*mol_vector2[1]+mol_vector2[2]*mol_vector2[2]);
          double inv_v2=1./norm_v2;
          double inv_v2_sqr=inv_v2*inv_v2;
          double inv_v1_inv_v2=inv_v1*inv_v2;
          double cosAngle=dotProduct(mol_vector1,mol_vector2)*inv_v1*inv_v2;
          Vector der_mol1=mol_vector2*inv_v1_inv_v2-cosAngle*mol_vector1*inv_v1_sqr;
          Vector der_mol2=mol_vector1*inv_v1_inv_v2-cosAngle*mol_vector2*inv_v2_sqr;
          if (doUpDownSymmetry && cosAngle<0) {
             der_mol1 *= -1.;
             der_mol2 *= -1.;
          }
          unsigned binAngle;
          if (doUpDownSymmetry && cosAngle<0) {
             binAngle=std::floor((-cosAngle-startCosAngle)/deltaCosAngle);
          } else {
             binAngle=std::floor((cosAngle-startCosAngle)/deltaCosAngle);
          }
          int minBin, maxBin; // These cannot be unsigned
          // Only consider contributions to g(r) of atoms less than n*sigma bins apart from the actual distance
          minBin=bin - deltaBin;
          if (minBin < 0) minBin=0;
          if (minBin > (nhist_[0]-1)) minBin=nhist_[0]-1;
          maxBin=bin +  deltaBin;
          if (maxBin > (nhist_[0]-1)) maxBin=nhist_[0]-1;
          int minBinAngle, maxBinAngle; // These cannot be unsigned
          // Only consider contributions to g(r) of atoms less than n*sigma bins apart from the actual angle
          minBinAngle=binAngle - deltaBinAngle;
          maxBinAngle=binAngle +  deltaBinAngle;
          for(int k=minBin;k<maxBin+1;k+=1) {
            double invNormKernel=invNormConstantBase/x1sqr[k];
            vector<double> pos(2);
            pos[0]=x1[k]-distanceModulo;
            for(int l=minBinAngle;l<maxBinAngle+1;l+=1) {
               double theta=startCosAngle+deltaCosAngle*l;
               if (doUpDownSymmetry && cosAngle<0) {
                  pos[1]=theta+cosAngle;
               } else {
                  pos[1]=theta-cosAngle;
               }
               // Include periodic effects
               int h;
               if (l<0) {
                  h=-l;
               } else if (l>(nhist_[1]-1)) {
                  h=2*nhist_[1]-l-2;
               } else {
                  h=l;
               }
               vector<double> dfunc(2);
               if (l==(nhist_[1]-1) || l==0) {
                  gofr[k][h] += kernel(pos,2*invNormKernel,dfunc);
               } else {
                  gofr[k][h] += kernel(pos,invNormKernel,dfunc);
               }
               Vector value1 = dfunc[0]*distance_versor;
               Vector value2_mol1 = dfunc[1]*der_mol1;
               Vector value2_mol2 = dfunc[1]*der_mol2;

               gofrPrimeCenter[i*nhist1_nhist2_+k*nhist_[1]+h] += value1;
               gofrPrimeStart[i*nhist1_nhist2_+k*nhist_[1]+h] +=  value2_mol1;
               gofrPrimeEnd[i*nhist1_nhist2_+k*nhist_[1]+h] -=  value2_mol1;


               gofrPrimeCenter[j*nhist1_nhist2_+k*nhist_[1]+h] -= value1;
               gofrPrimeStart[j*nhist1_nhist2_+k*nhist_[1]+h] +=  value2_mol2;
               gofrPrimeEnd[j*nhist1_nhist2_+k*nhist_[1]+h] -=  value2_mol2;

               Tensor vv1(value1, distance);
               Tensor vv2_mol1(value2_mol1, mol_vector1);
               Tensor vv2_mol2(value2_mol2, mol_vector2);
               gofrVirial[k][h] += vv1 + vv2_mol1 + vv2_mol2;
            }
          }
        }
      }
    }
  }
  //std::cout << "Main loop: " << float( clock () - begin_time ) << "\n";
  //begin_time = clock();
  if(!serial){
    comm.Sum(gofr);
    if (!doNotCalculateDerivatives() ) {
       comm.Sum(gofrVirial);
       if (!doLowComm) {
          comm.Sum(gofrPrimeCenter);
          comm.Sum(gofrPrimeStart);
          comm.Sum(gofrPrimeEnd);
       }
    }
  }
  //std::cout << "Communication: " <<  float( clock () - begin_time ) << "\n";
  //begin_time = clock();
  if (doAverageGofr) {
     if (!doNotCalculateDerivatives()) error("Cannot calculate derivatives or bias using the AVERAGE_GOFR option");
     double factor;
     if (averageGofrTau==0 || iteration < averageGofrTau) {
        iteration += 1;
        factor = 1./( (double) iteration );
     } else factor = 2./((double) averageGofrTau + 1.);
     for(unsigned i=0;i<nhist_[0];++i){
        for(unsigned j=0;j<nhist_[1];++j){
           avgGofr[i][j] += (gofr[i][j]-avgGofr[i][j])*factor;
           gofr[i][j] = avgGofr[i][j];
        }
     }
  }
  // Output of gofr
  if (doOutputGofr && (getStep()%outputStride==0)) outputGofr(gofr,"gofr.txt");
  // Construct integrand
  Matrix<double> integrand(nhist_[0],nhist_[1]);
  Matrix<double> logGofrx1sqr(nhist_[0],nhist_[1]);
  for(unsigned i=0;i<nhist_[0];++i){
     for(unsigned j=0;j<nhist_[1];++j){
        if (doReferenceGofr) {
           if (gofr[i][j]<1.e-10) {
              integrand[i][j] = (referenceGofr[i][j]+epsilon)*x1sqr[i];
           } else {
              logGofrx1sqr[i][j] = std::log(gofr[i][j]/(referenceGofr[i][j]+epsilon))*x1sqr[i];
              integrand[i][j] = gofr[i][j]*logGofrx1sqr[i][j]+(-gofr[i][j]+referenceGofr[i][j]+epsilon)*x1sqr[i];
           }
        } else {
           if (gofr[i][j]<1.e-10) {
              integrand[i][j] = x1sqr[i];
           } else {
              logGofrx1sqr[i][j] = std::log(gofr[i][j])*x1sqr[i];
              integrand[i][j] = gofr[i][j]*logGofrx1sqr[i][j]+(-gofr[i][j]+1)*x1sqr[i];
           }
        }
     }
  }
  vector<double> delta(2);
  delta[0]=deltar;
  delta[1]=deltaCosAngle;
  double TwoPiDensityVolAngles;
  if (densityReference>0) TwoPiDensityVolAngles=(2*pi/volumeOfAngles)*densityReference;
  else TwoPiDensityVolAngles=(2*pi/volumeOfAngles)*density;
  double pairEntropy=-TwoPiDensityVolAngles*integrate(integrand,delta);
  //std::cout << "Integrand and integration: " << float( clock () - begin_time ) << "\n";
  //begin_time = clock();
  // Derivatives
  vector<Vector> deriv(getNumberOfAtoms());
  Tensor virial;
  if (!doNotCalculateDerivatives() ) {
    if (doneigh) {
       for(unsigned int k=0;k<nl->getNumberOfLocalAtoms();k+=1) {
         unsigned index=nl->getIndexOfLocalAtom(k);
         // Center atom
         unsigned start_atom=index+center_lista.size();
         unsigned end_atom=index+center_lista.size()+start_lista.size();
         Matrix<Vector> integrandDerivatives(nhist_[0],nhist_[1]);
         Matrix<Vector> integrandDerivativesStart(nhist_[0],nhist_[1]);
         Matrix<Vector> integrandDerivativesEnd(nhist_[0],nhist_[1]);
         for(unsigned i=0;i<nhist_[0];++i){
           for(unsigned j=0;j<nhist_[1];++j){
             if (gofr[i][j]>1.e-10) {
               integrandDerivatives[i][j] = gofrPrimeCenter[index*nhist1_nhist2_+i*nhist_[1]+j]*logGofrx1sqr[i][j];
               integrandDerivativesStart[i][j] = gofrPrimeStart[index*nhist1_nhist2_+i*nhist_[1]+j]*logGofrx1sqr[i][j];
               integrandDerivativesEnd[i][j] = gofrPrimeEnd[index*nhist1_nhist2_+i*nhist_[1]+j]*logGofrx1sqr[i][j];
             }
           }
         }
         deriv[index] = -TwoPiDensityVolAngles*integrate(integrandDerivatives,delta);
         deriv[start_atom] = -TwoPiDensityVolAngles*integrate(integrandDerivativesStart,delta);
         deriv[end_atom] = -TwoPiDensityVolAngles*integrate(integrandDerivativesEnd,delta);
       }
    } else {
       for(unsigned int k=rank;k<center_lista.size();k+=stride) {
         // Center atom
         unsigned start_atom=k+center_lista.size();
         unsigned end_atom=k+center_lista.size()+start_lista.size();
         Matrix<Vector> integrandDerivatives(nhist_[0],nhist_[1]);
         Matrix<Vector> integrandDerivativesStart(nhist_[0],nhist_[1]);
         Matrix<Vector> integrandDerivativesEnd(nhist_[0],nhist_[1]);
         for(unsigned i=0;i<nhist_[0];++i){
           for(unsigned j=0;j<nhist_[1];++j){
             if (gofr[i][j]>1.e-10) {
               integrandDerivatives[i][j] = gofrPrimeCenter[k*nhist1_nhist2_+i*nhist_[1]+j]*logGofrx1sqr[i][j];
               integrandDerivativesStart[i][j] = gofrPrimeStart[k*nhist1_nhist2_+i*nhist_[1]+j]*logGofrx1sqr[i][j];
               integrandDerivativesEnd[i][j] = gofrPrimeEnd[k*nhist1_nhist2_+i*nhist_[1]+j]*logGofrx1sqr[i][j];
             }
           }
         }
         deriv[k] = -TwoPiDensityVolAngles*integrate(integrandDerivatives,delta);
         deriv[start_atom] = -TwoPiDensityVolAngles*integrate(integrandDerivativesStart,delta);
         deriv[end_atom] = -TwoPiDensityVolAngles*integrate(integrandDerivativesEnd,delta);
       }
    }
    if(!serial){
      comm.Sum(&deriv[0][0],3*getNumberOfAtoms());
    }
    // Virial of positions
    // Construct virial integrand
    Matrix<Tensor> integrandVirial(nhist_[0],nhist_[1]);
    for(unsigned i=0;i<nhist_[0];++i){
       for(unsigned j=0;j<nhist_[1];++j){
          if (gofr[i][j]>1.e-10) {
             integrandVirial[i][j] = gofrVirial[i][j]*logGofrx1sqr[i][j];
          }
      }
    }
    // Integrate virial
    virial = -TwoPiDensityVolAngles*integrate(integrandVirial,delta);
    // Virial of volume
    // Construct virial integrand
    Matrix<double> integrandVirialVolume(nhist_[0],nhist_[1]);
    for(unsigned i=0;i<nhist_[0];++i){
       for(unsigned j=0;j<nhist_[1];++j){
          if (densityReference>0) {
            integrandVirialVolume[i][j] = -gofr[i][j]*logGofrx1sqr[i][j];
          } else if (doReferenceGofr && densityReference<0) {
            integrandVirialVolume[i][j] = (-gofr[i][j]+referenceGofr[i][j]+epsilon)*x1sqr[i];
          } else {
            integrandVirialVolume[i][j] = (-gofr[i][j]+1)*x1sqr[i];
          }
       }
    }
    // Integrate virial
    virial += -TwoPiDensityVolAngles*integrate(integrandVirialVolume,delta)*Tensor::identity();
  }
  //std::cout << "Derivatives integration: " << float( clock () - begin_time ) << "\n";
  // Assign output quantities
  for(unsigned i=0;i<deriv.size();++i) setAtomsDerivatives(i,deriv[i]);
  setValue           (pairEntropy);
  setBoxDerivatives  (virial);
}

double PairOrientationalEntropy::kernel(vector<double> distance, double invNormKernel, vector<double>&der)const{
  // Gaussian function and derivative
  double result = invNormKernel*std::exp(-distance[0]*distance[0]/twoSigma1Sqr-distance[1]*distance[1]/twoSigma2Sqr) ;
  //double result = invTwoPiSigma1Sigma2*std::exp(-distance[0]*distance[0]/twoSigma1Sqr-distance[1]*distance[1]/twoSigma2Sqr) ;
  der[0] = -distance[0]*result/sigma1Sqr;
  der[1] = -distance[1]*result/sigma2Sqr;
  return result;
}

double PairOrientationalEntropy::integrate(Matrix<double> integrand, vector<double> delta)const{
  // Trapezoid rule
  double result = 0.;
  for(unsigned i=1;i<(nhist_[0]-1);++i){
     for(unsigned j=1;j<(nhist_[1]-1);++j){
        result += integrand[i][j];
     }
  }
  // Edges
  for(unsigned i=1;i<(nhist_[0]-1);++i){
     result += 0.5*integrand[i][0];
     result += 0.5*integrand[i][nhist_[1]-1];
  }
  for(unsigned j=1;j<(nhist_[1]-1);++j){
     result += 0.5*integrand[0][j];
     result += 0.5*integrand[nhist_[0]-1][j];
  }
  // Corners
  result += 0.25*integrand[0][0];
  result += 0.25*integrand[nhist_[0]-1][0];
  result += 0.25*integrand[0][nhist_[1]-1];
  result += 0.25*integrand[nhist_[0]-1][nhist_[1]-1];
  // Spacing
  result *= delta[0]*delta[1];
  return result;
}

Vector PairOrientationalEntropy::integrate(Matrix<Vector> integrand, vector<double> delta)const{
  // Trapezoid rule
  Vector result;
  for(unsigned i=1;i<(nhist_[0]-1);++i){
     for(unsigned j=1;j<(nhist_[1]-1);++j){
        result += integrand[i][j];
     }
  }
  // Edges
  for(unsigned i=1;i<(nhist_[0]-1);++i){
     result += 0.5*integrand[i][0];
     result += 0.5*integrand[i][nhist_[1]-1];
  }
  for(unsigned j=1;j<(nhist_[1]-1);++j){
     result += 0.5*integrand[0][j];
     result += 0.5*integrand[nhist_[0]-1][j];
  }
  // Corners
  result += 0.25*integrand[0][0];
  result += 0.25*integrand[nhist_[0]-1][0];
  result += 0.25*integrand[0][nhist_[1]-1];
  result += 0.25*integrand[nhist_[0]-1][nhist_[1]-1];
  // Spacing
  result *= delta[0]*delta[1];
  return result;
}

Tensor PairOrientationalEntropy::integrate(Matrix<Tensor> integrand, vector<double> delta)const{
  // Trapezoid rule
  Tensor result;
  for(unsigned i=1;i<(nhist_[0]-1);++i){
     for(unsigned j=1;j<(nhist_[1]-1);++j){
        result += integrand[i][j];
     }
  }
  // Edges
  for(unsigned i=1;i<(nhist_[0]-1);++i){
     result += 0.5*integrand[i][0];
     result += 0.5*integrand[i][nhist_[1]-1];
  }
  for(unsigned j=1;j<(nhist_[1]-1);++j){
     result += 0.5*integrand[0][j];
     result += 0.5*integrand[nhist_[0]-1][j];
  }
  // Corners
  result += 0.25*integrand[0][0];
  result += 0.25*integrand[nhist_[0]-1][0];
  result += 0.25*integrand[0][nhist_[1]-1];
  result += 0.25*integrand[nhist_[0]-1][nhist_[1]-1];
  // Spacing
  result *= delta[0]*delta[1];
  return result;
}

void PairOrientationalEntropy::outputGofr(Matrix<double> gofr, const char* fileName) {
  for(unsigned i=0;i<nhist_[0];++i){
     for(unsigned j=0;j<nhist_[1];++j){
        gofrOfile.printField("r",x1[i]).printField("theta",x2[j]).printField("gofr",gofr[i][j]).printField();
     }
     gofrOfile.printf("\n");
  }
  gofrOfile.printf("\n");
  gofrOfile.printf("\n");
}

}
}
src/colvar/PairOrientationalEntropyPerpendicular.cpp0000777000175000017500000016323513777445145022402 0ustar  maplemaple/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   Copyright (c) 2011-2016 The plumed team
   (see the PEOPLE file at the root of the distribution for a list of names)

   See http://www.plumed.org for more information.

   This file is part of plumed, version 2.

   plumed is free software: you can redistribute it and/or modify
   it under the terms of the GNU Lesser General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   plumed is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public License
   along with plumed.  If not, see <http://www.gnu.org/licenses/>.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
#include "Colvar.h"
#include "ActionRegister.h"
#include "tools/NeighborListParallel.h"
#include "tools/Communicator.h"
#include "tools/Tools.h"
#include "tools/IFile.h"

#include <string>
#include <math.h>

using namespace std;

namespace PLMD{
namespace colvar{

//+PLUMEDOC COLVAR PAIRENTROPY
/*
Calculate the global pair entropy using the expression:
\f[
s=-2\pi\rho k_B \int\limits_0^{r_{\mathrm{max}}} \left [ g(r) \ln g(r) - g(r) + 1 \right ] r^2 dr .
\f]
where \f$ g(r) $\f is the pair distribution function and \f$ r_{\mathrm{max}} $\f is a cutoff in the integration (MAXR).
For the integration the interval from 0 to  \f$ r_{\mathrm{max}} $\f is partitioned in NHIST equal intervals. 
To make the calculation of \f$ g(r) $\f differentiable, the following function is used:
\f[
g(r) = \frac{1}{4 \pi \rho r^2} \sum\limits_{j} \frac{1}{\sqrt{2 \pi \sigma^2}} e^{-(r-r_{ij})^2/(2\sigma^2)} ,
\f]
where \f$ \rho $\f is the density and \f$ sigma $\f is a broadening parameter (SIGMA).  
\par Example)
The following input tells plumed to calculate the pair entropy of atoms 1-250 with themselves.
\verbatim
PAIRENTROPY ...
 LABEL=s2
 GROUPA=1-250
 MAXR=0.65
 SIGMA=0.025
 NHIST=100
 NLIST
 NL_CUTOFF=0.75
 NL_STRIDE=10
... PAIRENTROPY
\endverbatim
*/
//+ENDPLUMEDOC

class PairOrientationalEntropyPerpendicular : public Colvar {
  bool pbc, serial, invalidateList, firsttime, doneigh;
  NeighborListParallel *nl;
  vector<AtomNumber> center_lista,start1_lista,end1_lista,start2_lista,end2_lista;
  std::vector<PLMD::AtomNumber> atomsToRequest;
  double maxr;
  vector<int> nhist_;
  int nhist1_nhist2_;
  vector<double> sigma_;
  double rcut2;
  double invTwoPiSigma1Sigma2, sigma1Sqr, sigma2Sqr, twoSigma1Sqr,twoSigma2Sqr;
  double deltar, deltaAngle, deltaCosAngle;
  unsigned deltaBin, deltaBinAngle;
  // Integration routines
  double integrate(Matrix<double> integrand, vector<double> delta)const;
  Vector integrate(Matrix<Vector> integrand, vector<double> delta)const;
  Tensor integrate(Matrix<Tensor> integrand, vector<double> delta)const;
  vector<double> x1, x2, x1sqr, x2sqr;
  // Kernel to calculate g(r)
  double kernel(vector<double> distance, double invNormKernel, vector<double>&der)const;
  // Output gofr and integrand
  void outputGofr(Matrix<double> gofr, const char* fileName);
  void outputIntegrand(vector<double> integrand);
  int outputStride;
  bool doOutputGofr, doOutputIntegrand;
  mutable PLMD::OFile gofrOfile;
  // Reference g(r)
  bool doReferenceGofr;
  Matrix<double> referenceGofr;
  double epsilon;
  double densityReference;
  // Average gofr
  Matrix<double> avgGofr;
  unsigned iteration;
  bool doAverageGofr;
  unsigned averageGofrTau;
  // Up-down symmetry
  bool doUpDownSymmetry;
  double startCosAngle;
  // Low communication variant
  bool doLowComm;
public:
  explicit PairOrientationalEntropyPerpendicular(const ActionOptions&);
  ~PairOrientationalEntropyPerpendicular();
  virtual void calculate();
  virtual void prepare();
  static void registerKeywords( Keywords& keys );
};

PLUMED_REGISTER_ACTION(PairOrientationalEntropyPerpendicular,"PAIR_ORIENTATIONAL_ENTROPY_PERPENDICULAR")

void PairOrientationalEntropyPerpendicular::registerKeywords( Keywords& keys ){
  Colvar::registerKeywords(keys);
  keys.addFlag("SERIAL",false,"Perform the calculation in serial - for debug purpose");
  keys.addFlag("NLIST",false,"Use a neighbour list to speed up the calculation");
  keys.addFlag("OUTPUT_GOFR",false,"Output g(r)");
  keys.addFlag("AVERAGE_GOFR",false,"Average g(r) over time");
  keys.add("optional","AVERAGE_GOFR_TAU","Characteristic length of a window in which to average the g(r). It is in units of iterations and should be an integer. Zero corresponds to an normal average (infinite window).");
  keys.addFlag("UP_DOWN_SYMMETRY",false,"The symmetry is such that parallel and antiparallel vectors are not distinguished. The angle goes from 0 to pi/2 instead of from 0 to pi.");
  keys.add("optional","OUTPUT_STRIDE","The frequency with which the output is written to files");
  keys.addFlag("OUTPUT_INTEGRAND",false,"Output integrand");
  keys.add("optional","NL_CUTOFF","The cutoff for the neighbour list");
  keys.add("optional","NL_STRIDE","The frequency with which we are updating the atoms in the neighbour list");
  keys.add("atoms","ORIGIN","Define an atom that represents the origin from which to calculate the g(r,theta)");
  keys.add("atoms","CENTER","Center atoms");
  keys.add("atoms","START1","Start point of first vector defining orientation");
  keys.add("atoms","START2","Start point of second vector defining orientation");
  keys.add("atoms","END1","End point of first vector defining orientation");
  keys.add("atoms","END2","End point of second vector defining orientation");
  keys.add("compulsory","MAXR","1","Maximum distance for the radial distribution function ");
  keys.add("optional","NHIST","Number of bins in the rdf ");
  keys.add("compulsory","SIGMA","0.1","Width of gaussians ");
  keys.add("optional","REFERENCE_GOFR_FNAME","the name of the file with the reference g(r)");
  keys.add("optional","REFERENCE_DENSITY","Density to be used with the reference g(r). If not specified or less than 0, the current density is used. Using the current density might lead in large changes of the box volume.");
  keys.addFlag("LOW_COMM",false,"Use an algorithm with less communication between processors");
}

PairOrientationalEntropyPerpendicular::PairOrientationalEntropyPerpendicular(const ActionOptions&ao):
PLUMED_COLVAR_INIT(ao),
pbc(true),
serial(false),
invalidateList(true),
firsttime(true)
{

  parseFlag("SERIAL",serial);

  parseAtomList("CENTER",center_lista);
  parseAtomList("START1",start1_lista);
  parseAtomList("END1",end1_lista);
  parseAtomList("START2",start2_lista);
  parseAtomList("END2",end2_lista);
  if(center_lista.size()!=start1_lista.size()) error("Number of atoms in START1 must be equal to the number of atoms in CENTER");
  if(center_lista.size()!=end1_lista.size()) error("Number of atoms in END1 must be equal to the number of atoms in CENTER");
  if(center_lista.size()!=start2_lista.size()) error("Number of atoms in START2 must be equal to the number of atoms in CENTER");
  if(center_lista.size()!=end2_lista.size()) error("Number of atoms in END2 must be equal to the number of atoms in CENTER");

  bool nopbc=!pbc;
  pbc=!nopbc;

// neighbor list stuff
  doneigh=false;
  bool nl_full_list=false;
  double nl_cut=0.0;
  double nl_skin;
  int nl_st=-1;
  parseFlag("NLIST",doneigh);
  if(doneigh){
   parse("NL_CUTOFF",nl_cut);
   if(nl_cut<=0.0) error("NL_CUTOFF should be explicitly specified and positive");
   parse("NL_STRIDE",nl_st);
   //if(nl_st<=0) error("NL_STRIDE should be explicitly specified and positive");
  }

  if(pbc) log.printf("  using periodic boundary conditions\n");
  else    log.printf("  without periodic boundary conditions\n");

  addValueWithDerivatives(); setNotPeriodic();

  parse("MAXR",maxr);
  log.printf("  Integration in the interval from 0. to %f \n", maxr );

  parseVector("SIGMA",sigma_);
  if(sigma_.size() != 2) error("SIGMA keyword takes two input values");
  log.printf("  The pair distribution function is calculated with a Gaussian kernel with deviations %f and %f \n", sigma_[0], sigma_[1]);
  double rcut = maxr + 2*sigma_[0];  // 2*sigma is hard coded
  rcut2 = rcut*rcut;
  if(doneigh){
    if(nl_cut<rcut) error("NL_CUTOFF should be larger than MAXR + 2*SIGMA");
    nl_skin=nl_cut-rcut;
  }

  doUpDownSymmetry=false;
  parseFlag("UP_DOWN_SYMMETRY",doUpDownSymmetry);
  if (doUpDownSymmetry) log.printf("  The angle can take values between 0 and pi/2 due to the up down symmetry. \n");

  parseVector("NHIST",nhist_);
  if (nhist_.size()<1) {
     nhist_.resize(2);
     // Default values
     nhist_[0]=ceil(maxr/sigma_[0]) + 1; 
     if (doUpDownSymmetry) nhist_[1]=ceil(1./sigma_[1]) + 1;
     else nhist_[1]=ceil(2./sigma_[1]) + 1;
  }
  if(nhist_.size() != 2) error("NHIST keyword takes two input values");
  nhist1_nhist2_=nhist_[0]*nhist_[1];
  log.printf("  The r-theta space is discretized using a grid of size %u times %u. \n", nhist_[0], nhist_[1] );
  log.printf("  The integration is performed with the trapezoid rule. \n");

  doOutputGofr=false;
  parseFlag("OUTPUT_GOFR",doOutputGofr);
  if (doOutputGofr) { 
     log.printf("  The g(r) will be written to a file \n");
     gofrOfile.link(*this);
     gofrOfile.open("gofr.txt");
  }
  doOutputIntegrand=false;
  parseFlag("OUTPUT_INTEGRAND",doOutputIntegrand);
  if (doOutputIntegrand) {
     log.printf("  The integrand will be written to a file \n");
  }
  outputStride=1;
  parse("OUTPUT_STRIDE",outputStride);
  if (outputStride!=1 && !doOutputGofr && !doOutputIntegrand) error("Cannot specify OUTPUT_STRIDE if OUTPUT_GOFR or OUTPUT_INTEGRAND not used");
  if (outputStride<1) error("The output stride specified with OUTPUT_STRIDE must be greater than or equal to one.");
  if (outputStride>1) log.printf("  The output stride to write g(r) or the integrand is %d \n", outputStride);

  densityReference=-1.;
  parse("REFERENCE_DENSITY",densityReference);
  if (densityReference>0) log.printf("  Using a density reference of %f .\n", densityReference);

  doReferenceGofr=false;
  std::string referenceGofrFileName;
  parse("REFERENCE_GOFR_FNAME",referenceGofrFileName); 
  if (!referenceGofrFileName.empty() ) {
    epsilon=1.e-8;
    log.printf("  Reading a reference g(r) from the file %s . \n", referenceGofrFileName.c_str() );
    doReferenceGofr=true;
    IFile ifile; 
    ifile.link(*this);
    ifile.open(referenceGofrFileName);
    referenceGofr.resize(nhist_[0],nhist_[1]);
    for(unsigned int i=0;i<nhist_[0];i++) {
       for(unsigned int j=0;j<nhist_[1];j++) {
       double tmp_r, tmp_theta;
       ifile.scanField("r",tmp_r).scanField("theta",tmp_theta).scanField("gofr",referenceGofr[i][j]).scanField();
       }
    }
  }

  doAverageGofr=false;
  parseFlag("AVERAGE_GOFR",doAverageGofr);
  if (doAverageGofr) {
     iteration = 1;
     avgGofr.resize(nhist_[0],nhist_[1]);
  }
  averageGofrTau=0;
  parse("AVERAGE_GOFR_TAU",averageGofrTau);
  if (averageGofrTau!=0 && !doAverageGofr) error("AVERAGE_GOFR_TAU specified but AVERAGE_GOFR not given. Specify AVERAGE_GOFR or remove AVERAGE_GOFR_TAU");
  if (doAverageGofr && averageGofrTau==0) log.printf("The g(r) will be averaged over all frames \n");
  if (doAverageGofr && averageGofrTau!=0) log.printf("The g(r) will be averaged with a window of %d steps \n", averageGofrTau);



  doLowComm=false;
  parseFlag("LOW_COMM",doLowComm);
  if (doLowComm) {
     log.printf("  Using the low communication variant of the algorithm");
     nl_full_list=true;
  }

  checkRead();

  // Neighbor lists
  if (doneigh) {
    nl= new NeighborListParallel(center_lista,pbc,getPbc(),comm,log,nl_cut,nl_full_list,nl_st,nl_skin);
    log.printf("  using neighbor lists with\n");
    log.printf("  cutoff %f, and skin %f\n",nl_cut,nl_skin);
    if(nl_st>=0){
      log.printf("  update every %d steps\n",nl_st);
    } else {
      log.printf("  checking every step for dangerous builds and rebuilding as needed\n");
    }
  }
  atomsToRequest.reserve ( center_lista.size() + start1_lista.size() + end1_lista.size() + start2_lista.size() + end2_lista.size() );
  atomsToRequest.insert (atomsToRequest.end(), center_lista.begin(), center_lista.end() );
  atomsToRequest.insert (atomsToRequest.end(), start1_lista.begin(), start1_lista.end() );
  atomsToRequest.insert (atomsToRequest.end(), end1_lista.begin(), end1_lista.end() );
  atomsToRequest.insert (atomsToRequest.end(), start2_lista.begin(), start2_lista.end() );
  atomsToRequest.insert (atomsToRequest.end(), end2_lista.begin(), end2_lista.end() );
  requestAtoms(atomsToRequest);

  // Define heavily used expressions
  invTwoPiSigma1Sigma2 = (1./(2.*pi*sigma_[0]*sigma_[1]));
  sigma1Sqr = sigma_[0]*sigma_[0];
  sigma2Sqr = sigma_[1]*sigma_[1];
  twoSigma1Sqr = 2*sigma_[0]*sigma_[0];
  twoSigma2Sqr = 2*sigma_[1]*sigma_[1];
  deltar=maxr/(nhist_[0]-1);
  if (!doUpDownSymmetry) {
     deltaCosAngle=2./(nhist_[1]-1);
     startCosAngle=-1.;
  }
  else {
     deltaCosAngle=1./(nhist_[1]-1);
     startCosAngle=0.;
  }
  deltaBin = std::floor(2*sigma_[0]/deltar); // 2*sigma is hard coded
  deltaBinAngle = std::floor(2*sigma_[1]/deltaCosAngle); // 2*sigma is hard coded

  x1.resize(nhist_[0]);
  x1sqr.resize(nhist_[0]);
  x2.resize(nhist_[1]);
  x2sqr.resize(nhist_[1]);
  for(unsigned i=0;i<nhist_[0];++i){
     x1[i]=deltar*i;
     x1sqr[i]=x1[i]*x1[i];
  }
  for(unsigned i=0;i<nhist_[1];++i){
     x2[i]=startCosAngle+deltaCosAngle*i;
     x2sqr[i]=x2[i]*x2[i];
  }
}

PairOrientationalEntropyPerpendicular::~PairOrientationalEntropyPerpendicular(){
  if (doneigh) {
     nl->printStats();
     delete nl;
  }
  if (doOutputGofr) gofrOfile.close();
}

void PairOrientationalEntropyPerpendicular::prepare(){
  if(doneigh && nl->getStride()>0){
    if(firsttime) {
      invalidateList=true;
      firsttime=false;
    } else if ( (nl->getStride()>=0) &&  (getStep()%nl->getStride()==0) ){
      invalidateList=true;
    } else if ( (nl->getStride()<0) && !(nl->isListStillGood(getPositions())) ){
      invalidateList=true;
    } else {
      invalidateList=false;
    }
  }
}

// calculator
void PairOrientationalEntropyPerpendicular::calculate()
{
  //clock_t begin_time = clock();
  // Define intermediate quantities
  Matrix<double> gofr(nhist_[0],nhist_[1]);
  vector<Vector> gofrPrimeCenter(nhist_[0]*nhist_[1]*center_lista.size());
  vector<Vector> gofrPrimeStart1(nhist_[0]*nhist_[1]*center_lista.size());
  vector<Vector> gofrPrimeEnd1(nhist_[0]*nhist_[1]*center_lista.size());
  vector<Vector> gofrPrimeStart2(nhist_[0]*nhist_[1]*center_lista.size());
  vector<Vector> gofrPrimeEnd2(nhist_[0]*nhist_[1]*center_lista.size());
  Matrix<Tensor> gofrVirial(nhist_[0],nhist_[1]);
  // Calculate volume and density
  double volume=getBox().determinant();
  double density=center_lista.size()/volume;
  // Normalization of g(r)
  double normConstantBase = 2*pi*center_lista.size()*density;
  normConstantBase /= invTwoPiSigma1Sigma2;
  // Take into account "volume" of angles
  double volumeOfAngles;
  if (!doUpDownSymmetry) volumeOfAngles = 2.;
  else volumeOfAngles = 1.;
  normConstantBase /= volumeOfAngles;
  double invNormConstantBase = 1./normConstantBase;
  // Setup parallelization
  unsigned stride=comm.Get_size();
  unsigned rank=comm.Get_rank();
  if(serial){
    stride=1;
    rank=0;
  }else{
    stride=comm.Get_size();
    rank=comm.Get_rank();
  }
  if (doneigh && doLowComm) {
    if(invalidateList){
      vector<Vector> centerPositions(getPositions().begin(),getPositions().begin() + center_lista.size());
      nl->update(centerPositions);
    }
    for(unsigned int i=0;i<nl->getNumberOfLocalAtoms();i+=1) {

       unsigned index=nl->getIndexOfLocalAtom(i);
       unsigned atom1_mol1=index+center_lista.size();
       unsigned atom2_mol1=index+2*center_lista.size();
       unsigned atom3_mol1=index+3*center_lista.size();
       unsigned atom4_mol1=index+4*center_lista.size();
       std::vector<unsigned> neighbors=nl->getNeighbors(index);
 
       Vector position_index=getPosition(index);
       Vector mol1_vector1=pbcDistance(getPosition(atom1_mol1),getPosition(atom2_mol1)); 
       Vector mol1_vector2=pbcDistance(getPosition(atom3_mol1),getPosition(atom4_mol1)); 
       Vector mol_vector1=crossProduct(mol1_vector1,mol1_vector2); 
       double norm_v1 = std::sqrt(mol_vector1[0]*mol_vector1[0]+mol_vector1[1]*mol_vector1[1]+mol_vector1[2]*mol_vector1[2]);
       double inv_v1=1./norm_v1;
       double inv_v1_sqr=inv_v1*inv_v1;

       // Loop over neighbors
       for(unsigned int j=0;j<neighbors.size();j+=1) {  
          unsigned neighbor=neighbors[j];
          if(getAbsoluteIndex(index)==getAbsoluteIndex(neighbor)) continue;
          Vector distance=pbcDistance(position_index,getPosition(neighbor));
          double d2;
          if ( (d2=distance[0]*distance[0])<rcut2 && (d2+=distance[1]*distance[1])<rcut2 && (d2+=distance[2]*distance[2])<rcut2) {
             double distanceModulo=std::sqrt(d2);
             Vector distance_versor = distance / distanceModulo;
             unsigned bin=std::floor(distanceModulo/deltar);

             unsigned atom1_mol2=neighbor+center_lista.size();
             unsigned atom2_mol2=neighbor+2*center_lista.size();
             unsigned atom3_mol2=neighbor+3*center_lista.size();
             unsigned atom4_mol2=neighbor+4*center_lista.size();
          
             Vector mol2_vector1=pbcDistance(getPosition(atom1_mol2),getPosition(atom2_mol2)); 
             Vector mol2_vector2=pbcDistance(getPosition(atom3_mol2),getPosition(atom4_mol2)); 
             Vector mol_vector2=crossProduct(mol2_vector1,mol2_vector2); 
             double norm_v2 = std::sqrt(mol_vector2[0]*mol_vector2[0]+mol_vector2[1]*mol_vector2[1]+mol_vector2[2]*mol_vector2[2]);
             double inv_v2=1./norm_v2;
             double inv_v1_inv_v2=inv_v1*inv_v2;
             double cosAngle=dotProduct(mol_vector1,mol_vector2)*inv_v1*inv_v2;
             
             Vector der_cosTheta_mol1_vector1;
             der_cosTheta_mol1_vector1[0]=(-mol1_vector2[2]*mol_vector2[1]+mol1_vector2[1]*mol_vector2[2])*inv_v1_inv_v2 -cosAngle*inv_v1_sqr*(-mol1_vector2[2]*mol_vector1[1]+mol1_vector2[1]*mol_vector1[2]);
             der_cosTheta_mol1_vector1[1]=( mol1_vector2[2]*mol_vector2[0]-mol1_vector2[0]*mol_vector2[2])*inv_v1_inv_v2 -cosAngle*inv_v1_sqr*( mol1_vector2[2]*mol_vector1[0]-mol1_vector2[0]*mol_vector1[2]);
             der_cosTheta_mol1_vector1[2]=(-mol1_vector2[1]*mol_vector2[0]+mol1_vector2[0]*mol_vector2[1])*inv_v1_inv_v2 -cosAngle*inv_v1_sqr*(-mol1_vector2[1]*mol_vector1[0]+mol1_vector2[0]*mol_vector1[1]);
             
             Vector der_cosTheta_mol1_vector2;
             der_cosTheta_mol1_vector2[0]=( mol1_vector1[2]*mol_vector2[1]-mol1_vector1[1]*mol_vector2[2])*inv_v1_inv_v2 -cosAngle*inv_v1_sqr*( mol1_vector1[2]*mol_vector1[1]-mol1_vector1[1]*mol_vector1[2]);
             der_cosTheta_mol1_vector2[1]=(-mol1_vector1[2]*mol_vector2[0]+mol1_vector1[0]*mol_vector2[2])*inv_v1_inv_v2 -cosAngle*inv_v1_sqr*(-mol1_vector1[2]*mol_vector1[0]+mol1_vector1[0]*mol_vector1[2]);
             der_cosTheta_mol1_vector2[2]=( mol1_vector1[1]*mol_vector2[0]-mol1_vector1[0]*mol_vector2[1])*inv_v1_inv_v2 -cosAngle*inv_v1_sqr*( mol1_vector1[1]*mol_vector1[0]-mol1_vector1[0]*mol_vector1[1]);
             
             if (doUpDownSymmetry && cosAngle<0) {
                der_cosTheta_mol1_vector1 *= -1.;
                der_cosTheta_mol1_vector2 *= -1.;
             }
             
             unsigned binAngle;
             if (doUpDownSymmetry && cosAngle<0) {
                binAngle=std::floor((-cosAngle-startCosAngle)/deltaCosAngle);
             } else {
                binAngle=std::floor((cosAngle-startCosAngle)/deltaCosAngle);
             }
             int minBin, maxBin; // These cannot be unsigned
             // Only consider contributions to g(r) of atoms less than n*sigma bins apart from the actual distance
             minBin=bin - deltaBin;
             if (minBin < 0) minBin=0;
             if (minBin > (nhist_[0]-1)) minBin=nhist_[0]-1;
             maxBin=bin +  deltaBin;
             if (maxBin > (nhist_[0]-1)) maxBin=nhist_[0]-1;
             int minBinAngle, maxBinAngle; // These cannot be unsigned
             // Only consider contributions to g(r) of atoms less than n*sigma bins apart from the actual angle
             minBinAngle=binAngle - deltaBinAngle;
             maxBinAngle=binAngle +  deltaBinAngle;
             for(int k=minBin;k<maxBin+1;k+=1) {
               double invNormKernel=invNormConstantBase/x1sqr[k];
               vector<double> pos(2);
               pos[0]=x1[k]-distanceModulo;
               for(int l=minBinAngle;l<maxBinAngle+1;l+=1) {
                  double theta=startCosAngle+deltaCosAngle*l;
                  if (doUpDownSymmetry && cosAngle<0) {
                     pos[1]=theta+cosAngle;
                  } else {
                     pos[1]=theta-cosAngle;
                  }
                  // Include periodic effects
                  int h;
                  if (l<0) {
                     h=-l;
                  } else if (l>(nhist_[1]-1)) {
                     h=2*nhist_[1]-l-2;
                  } else {
                     h=l;
                  }
                  Vector value1;
                  vector<double> dfunc(2);
                  if (l==(nhist_[1]-1) || l==0) {
                     gofr[k][h] += kernel(pos,2*invNormKernel,dfunc)/2.;
                  } else {
                     gofr[k][h] += kernel(pos,invNormKernel,dfunc)/2.;
                  }
                  value1 = dfunc[0]*distance_versor;
                  Vector value2_mol1_vector1 = dfunc[1]*der_cosTheta_mol1_vector1;
                  Vector value2_mol1_vector2 = dfunc[1]*der_cosTheta_mol1_vector2;
                    
                  gofrPrimeCenter[index*nhist1_nhist2_+k*nhist_[1]+h] += value1;
                  gofrPrimeStart1[index*nhist1_nhist2_+k*nhist_[1]+h] +=  value2_mol1_vector1;
                  gofrPrimeEnd1[index*nhist1_nhist2_+k*nhist_[1]+h] -=  value2_mol1_vector1;
                  gofrPrimeStart2[index*nhist1_nhist2_+k*nhist_[1]+h] +=  value2_mol1_vector2;
                  gofrPrimeEnd2[index*nhist1_nhist2_+k*nhist_[1]+h] -=  value2_mol1_vector2;
             
                  Tensor vv1(value1, distance);
                  Tensor vv2_mol1_vector1(value2_mol1_vector1, mol1_vector1);
                  Tensor vv2_mol1_vector2(value2_mol1_vector2, mol1_vector2);
             
                  gofrVirial[k][h] += vv1/2. + vv2_mol1_vector1 + vv2_mol1_vector2;
               }
            }
          }
        }
     }
  } else if (doneigh && !doLowComm) {
    if(invalidateList){
      vector<Vector> centerPositions(getPositions().begin(),getPositions().begin() + center_lista.size());
      nl->update(centerPositions);
    }
    for(unsigned int i=0;i<nl->getNumberOfLocalAtoms();i+=1) {

       unsigned index=nl->getIndexOfLocalAtom(i);
       unsigned atom1_mol1=index+center_lista.size();
       unsigned atom2_mol1=index+2*center_lista.size();
       unsigned atom3_mol1=index+3*center_lista.size();
       unsigned atom4_mol1=index+4*center_lista.size();
       std::vector<unsigned> neighbors=nl->getNeighbors(index);
 
       Vector position_index=getPosition(index);
       Vector mol1_vector1=pbcDistance(getPosition(atom1_mol1),getPosition(atom2_mol1)); 
       Vector mol1_vector2=pbcDistance(getPosition(atom3_mol1),getPosition(atom4_mol1)); 
       Vector mol_vector1=crossProduct(mol1_vector1,mol1_vector2); 
       double norm_v1 = std::sqrt(mol_vector1[0]*mol_vector1[0]+mol_vector1[1]*mol_vector1[1]+mol_vector1[2]*mol_vector1[2]);
       double inv_v1=1./norm_v1;
       double inv_v1_sqr=inv_v1*inv_v1;

       // Loop over neighbors
       for(unsigned int j=0;j<neighbors.size();j+=1) {  
          unsigned neighbor=neighbors[j];
          Vector distance=pbcDistance(position_index,getPosition(neighbor));
          double d2;
          if ( (d2=distance[0]*distance[0])<rcut2 && (d2+=distance[1]*distance[1])<rcut2 && (d2+=distance[2]*distance[2])<rcut2) {
             double distanceModulo=std::sqrt(d2);
             Vector distance_versor = distance / distanceModulo;
             unsigned bin=std::floor(distanceModulo/deltar);

             unsigned atom1_mol2=neighbor+center_lista.size();
             unsigned atom2_mol2=neighbor+2*center_lista.size();
             unsigned atom3_mol2=neighbor+3*center_lista.size();
             unsigned atom4_mol2=neighbor+4*center_lista.size();
          
             Vector mol2_vector1=pbcDistance(getPosition(atom1_mol2),getPosition(atom2_mol2)); 
             Vector mol2_vector2=pbcDistance(getPosition(atom3_mol2),getPosition(atom4_mol2)); 
             Vector mol_vector2=crossProduct(mol2_vector1,mol2_vector2); 
             double norm_v2 = std::sqrt(mol_vector2[0]*mol_vector2[0]+mol_vector2[1]*mol_vector2[1]+mol_vector2[2]*mol_vector2[2]);
             double inv_v2=1./norm_v2;
             double inv_v2_sqr=inv_v2*inv_v2;
             double inv_v1_inv_v2=inv_v1*inv_v2;
             double cosAngle=dotProduct(mol_vector1,mol_vector2)*inv_v1*inv_v2;
             
             Vector der_cosTheta_mol1_vector1;
             der_cosTheta_mol1_vector1[0]=(-mol1_vector2[2]*mol_vector2[1]+mol1_vector2[1]*mol_vector2[2])*inv_v1_inv_v2 -cosAngle*inv_v1_sqr*(-mol1_vector2[2]*mol_vector1[1]+mol1_vector2[1]*mol_vector1[2]);
             der_cosTheta_mol1_vector1[1]=( mol1_vector2[2]*mol_vector2[0]-mol1_vector2[0]*mol_vector2[2])*inv_v1_inv_v2 -cosAngle*inv_v1_sqr*( mol1_vector2[2]*mol_vector1[0]-mol1_vector2[0]*mol_vector1[2]);
             der_cosTheta_mol1_vector1[2]=(-mol1_vector2[1]*mol_vector2[0]+mol1_vector2[0]*mol_vector2[1])*inv_v1_inv_v2 -cosAngle*inv_v1_sqr*(-mol1_vector2[1]*mol_vector1[0]+mol1_vector2[0]*mol_vector1[1]);
             
             Vector der_cosTheta_mol1_vector2;
             der_cosTheta_mol1_vector2[0]=( mol1_vector1[2]*mol_vector2[1]-mol1_vector1[1]*mol_vector2[2])*inv_v1_inv_v2 -cosAngle*inv_v1_sqr*( mol1_vector1[2]*mol_vector1[1]-mol1_vector1[1]*mol_vector1[2]);
             der_cosTheta_mol1_vector2[1]=(-mol1_vector1[2]*mol_vector2[0]+mol1_vector1[0]*mol_vector2[2])*inv_v1_inv_v2 -cosAngle*inv_v1_sqr*(-mol1_vector1[2]*mol_vector1[0]+mol1_vector1[0]*mol_vector1[2]);
             der_cosTheta_mol1_vector2[2]=( mol1_vector1[1]*mol_vector2[0]-mol1_vector1[0]*mol_vector2[1])*inv_v1_inv_v2 -cosAngle*inv_v1_sqr*( mol1_vector1[1]*mol_vector1[0]-mol1_vector1[0]*mol_vector1[1]);
             
             Vector der_cosTheta_mol2_vector1;
             der_cosTheta_mol2_vector1[0]=(-mol2_vector2[2]*mol_vector1[1]+mol2_vector2[1]*mol_vector1[2])*inv_v1_inv_v2 -cosAngle*inv_v2_sqr*(-mol2_vector2[2]*mol_vector2[1]+mol2_vector2[1]*mol_vector2[2]);
             der_cosTheta_mol2_vector1[1]=( mol2_vector2[2]*mol_vector1[0]-mol2_vector2[0]*mol_vector1[2])*inv_v1_inv_v2 -cosAngle*inv_v2_sqr*( mol2_vector2[2]*mol_vector2[0]-mol2_vector2[0]*mol_vector2[2]);
             der_cosTheta_mol2_vector1[2]=(-mol2_vector2[1]*mol_vector1[0]+mol2_vector2[0]*mol_vector1[1])*inv_v1_inv_v2 -cosAngle*inv_v2_sqr*(-mol2_vector2[1]*mol_vector2[0]+mol2_vector2[0]*mol_vector2[1]);
             
             Vector der_cosTheta_mol2_vector2;
             der_cosTheta_mol2_vector2[0]=( mol2_vector1[2]*mol_vector1[1]-mol2_vector1[1]*mol_vector1[2])*inv_v1_inv_v2 -cosAngle*inv_v2_sqr*( mol2_vector1[2]*mol_vector2[1]-mol2_vector1[1]*mol_vector2[2]);
             der_cosTheta_mol2_vector2[1]=(-mol2_vector1[2]*mol_vector1[0]+mol2_vector1[0]*mol_vector1[2])*inv_v1_inv_v2 -cosAngle*inv_v2_sqr*(-mol2_vector1[2]*mol_vector2[0]+mol2_vector1[0]*mol_vector2[2]);
             der_cosTheta_mol2_vector2[2]=( mol2_vector1[1]*mol_vector1[0]-mol2_vector1[0]*mol_vector1[1])*inv_v1_inv_v2 -cosAngle*inv_v2_sqr*( mol2_vector1[1]*mol_vector2[0]-mol2_vector1[0]*mol_vector2[1]);
             
             if (doUpDownSymmetry && cosAngle<0) {
                der_cosTheta_mol1_vector1 *= -1.;
                der_cosTheta_mol1_vector2 *= -1.;
                der_cosTheta_mol2_vector1 *= -1.;
                der_cosTheta_mol2_vector2 *= -1.;
             }
             
             unsigned binAngle;
             if (doUpDownSymmetry && cosAngle<0) {
                binAngle=std::floor((-cosAngle-startCosAngle)/deltaCosAngle);
             } else {
                binAngle=std::floor((cosAngle-startCosAngle)/deltaCosAngle);
             }
             int minBin, maxBin; // These cannot be unsigned
             // Only consider contributions to g(r) of atoms less than n*sigma bins apart from the actual distance
             minBin=bin - deltaBin;
             if (minBin < 0) minBin=0;
             if (minBin > (nhist_[0]-1)) minBin=nhist_[0]-1;
             maxBin=bin +  deltaBin;
             if (maxBin > (nhist_[0]-1)) maxBin=nhist_[0]-1;
             int minBinAngle, maxBinAngle; // These cannot be unsigned
             // Only consider contributions to g(r) of atoms less than n*sigma bins apart from the actual angle
             minBinAngle=binAngle - deltaBinAngle;
             maxBinAngle=binAngle +  deltaBinAngle;
             for(int k=minBin;k<maxBin+1;k+=1) {
               double invNormKernel=invNormConstantBase/x1sqr[k];
               vector<double> pos(2);
               pos[0]=x1[k]-distanceModulo;
               for(int l=minBinAngle;l<maxBinAngle+1;l+=1) {
                  double theta=startCosAngle+deltaCosAngle*l;
                  if (doUpDownSymmetry && cosAngle<0) {
                     pos[1]=theta+cosAngle;
                  } else {
                     pos[1]=theta-cosAngle;
                  }
                  // Include periodic effects
                  int h;
                  if (l<0) {
                     h=-l;
                  } else if (l>(nhist_[1]-1)) {
                     h=2*nhist_[1]-l-2;
                  } else {
                     h=l;
                  }
                  Vector value1;
                  vector<double> dfunc(2);
                  if (l==(nhist_[1]-1) || l==0) {
                     gofr[k][h] += kernel(pos,2*invNormKernel,dfunc);
                  } else {
                     gofr[k][h] += kernel(pos,invNormKernel,dfunc);
                  }
                  value1 = dfunc[0]*distance_versor;
                  Vector value2_mol1_vector1 = dfunc[1]*der_cosTheta_mol1_vector1;
                  Vector value2_mol1_vector2 = dfunc[1]*der_cosTheta_mol1_vector2;
                  Vector value2_mol2_vector1 = dfunc[1]*der_cosTheta_mol2_vector1;
                  Vector value2_mol2_vector2 = dfunc[1]*der_cosTheta_mol2_vector2;
                    
                  gofrPrimeCenter[index*nhist1_nhist2_+k*nhist_[1]+h] += value1;
                  gofrPrimeStart1[index*nhist1_nhist2_+k*nhist_[1]+h] +=  value2_mol1_vector1;
                  gofrPrimeEnd1[index*nhist1_nhist2_+k*nhist_[1]+h] -=  value2_mol1_vector1;
                  gofrPrimeStart2[index*nhist1_nhist2_+k*nhist_[1]+h] +=  value2_mol1_vector2;
                  gofrPrimeEnd2[index*nhist1_nhist2_+k*nhist_[1]+h] -=  value2_mol1_vector2;
             
                  gofrPrimeCenter[neighbor*nhist1_nhist2_+k*nhist_[1]+h] -= value1;
                  gofrPrimeStart1[neighbor*nhist1_nhist2_+k*nhist_[1]+h] +=  value2_mol2_vector1;
                  gofrPrimeEnd1[neighbor*nhist1_nhist2_+k*nhist_[1]+h] -=  value2_mol2_vector1;
                  gofrPrimeStart2[neighbor*nhist1_nhist2_+k*nhist_[1]+h] +=  value2_mol2_vector2;
                  gofrPrimeEnd2[neighbor*nhist1_nhist2_+k*nhist_[1]+h] -=  value2_mol2_vector2;
             
                  Tensor vv1(value1, distance);
                  Tensor vv2_mol1_vector1(value2_mol1_vector1, mol1_vector1);
                  Tensor vv2_mol1_vector2(value2_mol1_vector2, mol1_vector2);
                  Tensor vv2_mol2_vector1(value2_mol2_vector1, mol2_vector1);
                  Tensor vv2_mol2_vector2(value2_mol2_vector2, mol2_vector2);
             
                  gofrVirial[k][h] += vv1 + vv2_mol1_vector1 + vv2_mol1_vector2+ vv2_mol2_vector1 + vv2_mol2_vector2;
               }
            }
          }
        }
     }
  } else if (!doneigh && doLowComm) {
    for(unsigned int i=rank;i<center_lista.size();i+=stride) {
      unsigned atom1_mol1=i+center_lista.size();
      unsigned atom2_mol1=i+2*center_lista.size();
      unsigned atom3_mol1=i+3*center_lista.size();
      unsigned atom4_mol1=i+4*center_lista.size();

      Vector mol1_vector1=pbcDistance(getPosition(atom1_mol1),getPosition(atom2_mol1)); 
      Vector mol1_vector2=pbcDistance(getPosition(atom3_mol1),getPosition(atom4_mol1)); 
      Vector mol_vector1=crossProduct(mol1_vector1,mol1_vector2); 
      double norm_v1 = std::sqrt(mol_vector1[0]*mol_vector1[0]+mol_vector1[1]*mol_vector1[1]+mol_vector1[2]*mol_vector1[2]);
      double inv_v1=1./norm_v1;
      double inv_v1_sqr=inv_v1*inv_v1;

      for(unsigned int j=0;j<center_lista.size();j+=1) {
        double d2;
        Vector distance;
        Vector distance_versor;
        if(getAbsoluteIndex(i)==getAbsoluteIndex(j)) continue;
        if(pbc){
         distance=pbcDistance(getPosition(i),getPosition(j));
        } else {
         distance=delta(getPosition(i),getPosition(j));
        }
        if ( (d2=distance[0]*distance[0])<rcut2 && (d2+=distance[1]*distance[1])<rcut2 && (d2+=distance[2]*distance[2])<rcut2) {
          double distanceModulo=std::sqrt(d2);
          Vector distance_versor = distance / distanceModulo;
          unsigned bin=std::floor(distanceModulo/deltar);

          unsigned atom1_mol2=j+center_lista.size();
          unsigned atom2_mol2=j+2*center_lista.size();
          unsigned atom3_mol2=j+3*center_lista.size();
          unsigned atom4_mol2=j+4*center_lista.size();

          Vector mol2_vector1=pbcDistance(getPosition(atom1_mol2),getPosition(atom2_mol2)); 
          Vector mol2_vector2=pbcDistance(getPosition(atom3_mol2),getPosition(atom4_mol2)); 
          Vector mol_vector2=crossProduct(mol2_vector1,mol2_vector2); 
          double norm_v2 = std::sqrt(mol_vector2[0]*mol_vector2[0]+mol_vector2[1]*mol_vector2[1]+mol_vector2[2]*mol_vector2[2]);

          double inv_v2=1./norm_v2;
          double inv_v1_inv_v2=inv_v1*inv_v2;
          double cosAngle=dotProduct(mol_vector1,mol_vector2)*inv_v1*inv_v2;

          Vector der_cosTheta_vector1;
          der_cosTheta_vector1[0]=(-mol1_vector2[2]*mol_vector2[1]+mol1_vector2[1]*mol_vector2[2])*inv_v1_inv_v2 - cosAngle*inv_v1_sqr*(-mol1_vector2[2]*mol_vector1[1]+mol1_vector2[1]*mol_vector1[2]);
          der_cosTheta_vector1[1]=( mol1_vector2[2]*mol_vector2[0]-mol1_vector2[0]*mol_vector2[2])*inv_v1_inv_v2 - cosAngle*inv_v1_sqr*( mol1_vector2[2]*mol_vector1[0]-mol1_vector2[0]*mol_vector1[2]);
          der_cosTheta_vector1[2]=(-mol1_vector2[1]*mol_vector2[0]+mol1_vector2[0]*mol_vector2[1])*inv_v1_inv_v2 - cosAngle*inv_v1_sqr*(-mol1_vector2[1]*mol_vector1[0]+mol1_vector2[0]*mol_vector1[1]);

          Vector der_cosTheta_vector2;
          der_cosTheta_vector2[0]=( mol1_vector1[2]*mol_vector2[1]-mol1_vector1[1]*mol_vector2[2])*inv_v1_inv_v2 - cosAngle*inv_v1_sqr*( mol1_vector1[2]*mol_vector1[1]-mol1_vector1[1]*mol_vector1[2]);
          der_cosTheta_vector2[1]=(-mol1_vector1[2]*mol_vector2[0]+mol1_vector1[0]*mol_vector2[2])*inv_v1_inv_v2 - cosAngle*inv_v1_sqr*(-mol1_vector1[2]*mol_vector1[0]+mol1_vector1[0]*mol_vector1[2]);
          der_cosTheta_vector2[2]=( mol1_vector1[1]*mol_vector2[0]-mol1_vector1[0]*mol_vector2[1])*inv_v1_inv_v2 - cosAngle*inv_v1_sqr*( mol1_vector1[1]*mol_vector1[0]-mol1_vector1[0]*mol_vector1[1]);

          if (doUpDownSymmetry && cosAngle<0) {
             der_cosTheta_vector1 *= -1.;
             der_cosTheta_vector2 *= -1.;
          }

          unsigned binAngle;
          if (doUpDownSymmetry && cosAngle<0) {
             binAngle=std::floor((-cosAngle-startCosAngle)/deltaCosAngle);
          } else {
             binAngle=std::floor((cosAngle-startCosAngle)/deltaCosAngle);
          }
          int minBin, maxBin; // These cannot be unsigned
          // Only consider contributions to g(r) of atoms less than n*sigma bins apart from the actual distance
          minBin=bin - deltaBin;
          if (minBin < 0) minBin=0;
          if (minBin > (nhist_[0]-1)) minBin=nhist_[0]-1;
          maxBin=bin +  deltaBin;
          if (maxBin > (nhist_[0]-1)) maxBin=nhist_[0]-1;
          int minBinAngle, maxBinAngle; // These cannot be unsigned
          // Only consider contributions to g(r) of atoms less than n*sigma bins apart from the actual angle
          minBinAngle=binAngle - deltaBinAngle;
          maxBinAngle=binAngle +  deltaBinAngle;
          for(int k=minBin;k<maxBin+1;k+=1) {
            double invNormKernel=invNormConstantBase/x1sqr[k];
            vector<double> pos(2);
            pos[0]=x1[k]-distanceModulo;
            for(int l=minBinAngle;l<maxBinAngle+1;l+=1) {
               double theta=startCosAngle+deltaCosAngle*l;
               if (doUpDownSymmetry && cosAngle<0) {
                  pos[1]=theta+cosAngle;
               } else {
                  pos[1]=theta-cosAngle;
               }
               // Include periodic effects
               int h;
               if (l<0) {
                  h=-l;
               } else if (l>(nhist_[1]-1)) {
                  h=2*nhist_[1]-l-2;
               } else {
                  h=l;
               }
               Vector value1;
               Vector value2_mol1_vector1;
               Vector value2_mol1_vector2;
               vector<double> dfunc(2);
               if (l==(nhist_[1]-1) || l==0) {
                  gofr[k][h] += kernel(pos,2*invNormKernel,dfunc)/2.;
               } else {
                  gofr[k][h] += kernel(pos,invNormKernel,dfunc)/2.;
               }
               value1 = dfunc[0]*distance_versor;
               value2_mol1_vector1 = dfunc[1]*der_cosTheta_vector1;
               value2_mol1_vector2 = dfunc[1]*der_cosTheta_vector2;

               gofrPrimeCenter[i*nhist1_nhist2_+k*nhist_[1]+h] += value1;
               gofrPrimeStart1[i*nhist1_nhist2_+k*nhist_[1]+h] +=  value2_mol1_vector1;
               gofrPrimeEnd1[i*nhist1_nhist2_+k*nhist_[1]+h] -=  value2_mol1_vector1;
               gofrPrimeStart2[i*nhist1_nhist2_+k*nhist_[1]+h] +=  value2_mol1_vector2;
               gofrPrimeEnd2[i*nhist1_nhist2_+k*nhist_[1]+h] -=  value2_mol1_vector2;

               Tensor vv1(value1, distance);
               Tensor vv2_mol1_vector1(value2_mol1_vector1, mol1_vector1);
               Tensor vv2_mol1_vector2(value2_mol1_vector2, mol1_vector2);
               gofrVirial[k][h] += vv1/2. + vv2_mol1_vector1 + vv2_mol1_vector2;
            }
          }
        }
      }
    }
  } else if (!doneigh && !doLowComm) {
    for(unsigned int i=rank;i<(center_lista.size()-1);i+=stride) {
      unsigned atom1_mol1=i+center_lista.size();
      unsigned atom2_mol1=i+2*center_lista.size();
      unsigned atom3_mol1=i+3*center_lista.size();
      unsigned atom4_mol1=i+4*center_lista.size();

      Vector mol1_vector1=pbcDistance(getPosition(atom1_mol1),getPosition(atom2_mol1)); 
      Vector mol1_vector2=pbcDistance(getPosition(atom3_mol1),getPosition(atom4_mol1)); 
      Vector mol_vector1=crossProduct(mol1_vector1,mol1_vector2); 
      double norm_v1 = std::sqrt(mol_vector1[0]*mol_vector1[0]+mol_vector1[1]*mol_vector1[1]+mol_vector1[2]*mol_vector1[2]);
      double inv_v1=1./norm_v1;
      double inv_v1_sqr=inv_v1*inv_v1;

      for(unsigned int j=i+1;j<center_lista.size();j+=1) {
        double d2;
        Vector distance;
        Vector distance_versor;
        if(getAbsoluteIndex(i)==getAbsoluteIndex(j)) continue;
        if(pbc){
         distance=pbcDistance(getPosition(i),getPosition(j));
        } else {
         distance=delta(getPosition(i),getPosition(j));
        }
        if ( (d2=distance[0]*distance[0])<rcut2 && (d2+=distance[1]*distance[1])<rcut2 && (d2+=distance[2]*distance[2])<rcut2) {
          double distanceModulo=std::sqrt(d2);
          Vector distance_versor = distance / distanceModulo;
          unsigned bin=std::floor(distanceModulo/deltar);

          unsigned atom1_mol2=j+center_lista.size();
          unsigned atom2_mol2=j+2*center_lista.size();
          unsigned atom3_mol2=j+3*center_lista.size();
          unsigned atom4_mol2=j+4*center_lista.size();

          Vector mol2_vector1=pbcDistance(getPosition(atom1_mol2),getPosition(atom2_mol2)); 
          Vector mol2_vector2=pbcDistance(getPosition(atom3_mol2),getPosition(atom4_mol2)); 
          Vector mol_vector2=crossProduct(mol2_vector1,mol2_vector2); 
          double norm_v2 = std::sqrt(mol_vector2[0]*mol_vector2[0]+mol_vector2[1]*mol_vector2[1]+mol_vector2[2]*mol_vector2[2]);

          double inv_v2=1./norm_v2;
          double inv_v2_sqr=inv_v2*inv_v2;
          double inv_v1_inv_v2=inv_v1*inv_v2;
          double cosAngle=dotProduct(mol_vector1,mol_vector2)*inv_v1*inv_v2;

          Vector der_cosTheta_mol1_vector1;
          der_cosTheta_mol1_vector1[0]=(-mol1_vector2[2]*mol_vector2[1]+mol1_vector2[1]*mol_vector2[2])*inv_v1_inv_v2 -cosAngle*inv_v1_sqr*(-mol1_vector2[2]*mol_vector1[1]+mol1_vector2[1]*mol_vector1[2]);
          der_cosTheta_mol1_vector1[1]=( mol1_vector2[2]*mol_vector2[0]-mol1_vector2[0]*mol_vector2[2])*inv_v1_inv_v2 -cosAngle*inv_v1_sqr*( mol1_vector2[2]*mol_vector1[0]-mol1_vector2[0]*mol_vector1[2]);
          der_cosTheta_mol1_vector1[2]=(-mol1_vector2[1]*mol_vector2[0]+mol1_vector2[0]*mol_vector2[1])*inv_v1_inv_v2 -cosAngle*inv_v1_sqr*(-mol1_vector2[1]*mol_vector1[0]+mol1_vector2[0]*mol_vector1[1]);

          Vector der_cosTheta_mol1_vector2;
          der_cosTheta_mol1_vector2[0]=( mol1_vector1[2]*mol_vector2[1]-mol1_vector1[1]*mol_vector2[2])*inv_v1_inv_v2 -cosAngle*inv_v1_sqr*( mol1_vector1[2]*mol_vector1[1]-mol1_vector1[1]*mol_vector1[2]);
          der_cosTheta_mol1_vector2[1]=(-mol1_vector1[2]*mol_vector2[0]+mol1_vector1[0]*mol_vector2[2])*inv_v1_inv_v2 -cosAngle*inv_v1_sqr*(-mol1_vector1[2]*mol_vector1[0]+mol1_vector1[0]*mol_vector1[2]);
          der_cosTheta_mol1_vector2[2]=( mol1_vector1[1]*mol_vector2[0]-mol1_vector1[0]*mol_vector2[1])*inv_v1_inv_v2 -cosAngle*inv_v1_sqr*( mol1_vector1[1]*mol_vector1[0]-mol1_vector1[0]*mol_vector1[1]);

          Vector der_cosTheta_mol2_vector1;
          der_cosTheta_mol2_vector1[0]=(-mol2_vector2[2]*mol_vector1[1]+mol2_vector2[1]*mol_vector1[2])*inv_v1_inv_v2 -cosAngle*inv_v2_sqr*(-mol2_vector2[2]*mol_vector2[1]+mol2_vector2[1]*mol_vector2[2]);
          der_cosTheta_mol2_vector1[1]=( mol2_vector2[2]*mol_vector1[0]-mol2_vector2[0]*mol_vector1[2])*inv_v1_inv_v2 -cosAngle*inv_v2_sqr*( mol2_vector2[2]*mol_vector2[0]-mol2_vector2[0]*mol_vector2[2]);
          der_cosTheta_mol2_vector1[2]=(-mol2_vector2[1]*mol_vector1[0]+mol2_vector2[0]*mol_vector1[1])*inv_v1_inv_v2 -cosAngle*inv_v2_sqr*(-mol2_vector2[1]*mol_vector2[0]+mol2_vector2[0]*mol_vector2[1]);

          Vector der_cosTheta_mol2_vector2;
          der_cosTheta_mol2_vector2[0]=( mol2_vector1[2]*mol_vector1[1]-mol2_vector1[1]*mol_vector1[2])*inv_v1_inv_v2 -cosAngle*inv_v2_sqr*( mol2_vector1[2]*mol_vector2[1]-mol2_vector1[1]*mol_vector2[2]);
          der_cosTheta_mol2_vector2[1]=(-mol2_vector1[2]*mol_vector1[0]+mol2_vector1[0]*mol_vector1[2])*inv_v1_inv_v2 -cosAngle*inv_v2_sqr*(-mol2_vector1[2]*mol_vector2[0]+mol2_vector1[0]*mol_vector2[2]);
          der_cosTheta_mol2_vector2[2]=( mol2_vector1[1]*mol_vector1[0]-mol2_vector1[0]*mol_vector1[1])*inv_v1_inv_v2 -cosAngle*inv_v2_sqr*( mol2_vector1[1]*mol_vector2[0]-mol2_vector1[0]*mol_vector2[1]);

          if (doUpDownSymmetry && cosAngle<0) {
             der_cosTheta_mol1_vector1 *= -1.;
             der_cosTheta_mol1_vector2 *= -1.;
             der_cosTheta_mol2_vector1 *= -1.;
             der_cosTheta_mol2_vector2 *= -1.;
          }

          unsigned binAngle;
          if (doUpDownSymmetry && cosAngle<0) {
             binAngle=std::floor((-cosAngle-startCosAngle)/deltaCosAngle);
          } else {
             binAngle=std::floor((cosAngle-startCosAngle)/deltaCosAngle);
          }
          int minBin, maxBin; // These cannot be unsigned
          // Only consider contributions to g(r) of atoms less than n*sigma bins apart from the actual distance
          minBin=bin - deltaBin;
          if (minBin < 0) minBin=0;
          if (minBin > (nhist_[0]-1)) minBin=nhist_[0]-1;
          maxBin=bin +  deltaBin;
          if (maxBin > (nhist_[0]-1)) maxBin=nhist_[0]-1;
          int minBinAngle, maxBinAngle; // These cannot be unsigned
          // Only consider contributions to g(r) of atoms less than n*sigma bins apart from the actual angle
          minBinAngle=binAngle - deltaBinAngle;
          maxBinAngle=binAngle +  deltaBinAngle;
          for(int k=minBin;k<maxBin+1;k+=1) {
            double invNormKernel=invNormConstantBase/x1sqr[k];
            vector<double> pos(2);
            pos[0]=x1[k]-distanceModulo;
            for(int l=minBinAngle;l<maxBinAngle+1;l+=1) {
               double theta=startCosAngle+deltaCosAngle*l;
               if (doUpDownSymmetry && cosAngle<0) {
                  pos[1]=theta+cosAngle;
               } else {
                  pos[1]=theta-cosAngle;
               }
               // Include periodic effects
               int h;
               if (l<0) {
                  h=-l;
               } else if (l>(nhist_[1]-1)) {
                  h=2*nhist_[1]-l-2;
               } else {
                  h=l;
               }
               Vector value1;
               vector<double> dfunc(2);
               if (l==(nhist_[1]-1) || l==0) {
                  gofr[k][h] += kernel(pos,2*invNormKernel,dfunc);
               } else {
                  gofr[k][h] += kernel(pos,invNormKernel,dfunc);
               }
               value1 = dfunc[0]*distance_versor;
               Vector value2_mol1_vector1 = dfunc[1]*der_cosTheta_mol1_vector1;
               Vector value2_mol1_vector2 = dfunc[1]*der_cosTheta_mol1_vector2;
               Vector value2_mol2_vector1 = dfunc[1]*der_cosTheta_mol2_vector1;
               Vector value2_mol2_vector2 = dfunc[1]*der_cosTheta_mol2_vector2;
                 
               gofrPrimeCenter[i*nhist1_nhist2_+k*nhist_[1]+h] += value1;
               gofrPrimeStart1[i*nhist1_nhist2_+k*nhist_[1]+h] +=  value2_mol1_vector1;
               gofrPrimeEnd1[i*nhist1_nhist2_+k*nhist_[1]+h] -=  value2_mol1_vector1;
               gofrPrimeStart2[i*nhist1_nhist2_+k*nhist_[1]+h] +=  value2_mol1_vector2;
               gofrPrimeEnd2[i*nhist1_nhist2_+k*nhist_[1]+h] -=  value2_mol1_vector2;

               gofrPrimeCenter[j*nhist1_nhist2_+k*nhist_[1]+h] -= value1;
               gofrPrimeStart1[j*nhist1_nhist2_+k*nhist_[1]+h] +=  value2_mol2_vector1;
               gofrPrimeEnd1[j*nhist1_nhist2_+k*nhist_[1]+h] -=  value2_mol2_vector1;
               gofrPrimeStart2[j*nhist1_nhist2_+k*nhist_[1]+h] +=  value2_mol2_vector2;
               gofrPrimeEnd2[j*nhist1_nhist2_+k*nhist_[1]+h] -=  value2_mol2_vector2;

               Tensor vv1(value1, distance);
               Tensor vv2_mol1_vector1(value2_mol1_vector1, mol1_vector1);
               Tensor vv2_mol1_vector2(value2_mol1_vector2, mol1_vector2);
               Tensor vv2_mol2_vector1(value2_mol2_vector1, mol2_vector1);
               Tensor vv2_mol2_vector2(value2_mol2_vector2, mol2_vector2);

               gofrVirial[k][h] += vv1 + vv2_mol1_vector1 + vv2_mol1_vector2+ vv2_mol2_vector1 + vv2_mol2_vector2;
            }
          }
        }
      }
    }
  }
  //std::cout << "Main loop: " << float( clock () - begin_time ) << "\n";
  //begin_time = clock();
  if(!serial){
    comm.Sum(gofr);
    if (!doNotCalculateDerivatives() ) {
       comm.Sum(gofrVirial);
       if (!doLowComm) {
          comm.Sum(gofrPrimeCenter);
          comm.Sum(gofrPrimeStart1);
          comm.Sum(gofrPrimeEnd1);
          comm.Sum(gofrPrimeStart2);
          comm.Sum(gofrPrimeEnd2);
       }
    }
  }
  //std::cout << "Communication: " <<  float( clock () - begin_time ) << "\n";
  //begin_time = clock();
  if (doAverageGofr) {
     if (!doNotCalculateDerivatives()) error("Cannot calculate derivatives or bias using the AVERAGE_GOFR option");
     double factor;
     if (averageGofrTau==0 || iteration < averageGofrTau) {
        iteration += 1;
        factor = 1./( (double) iteration );
     } else factor = 2./((double) averageGofrTau + 1.);
     for(unsigned i=0;i<nhist_[0];++i){
        for(unsigned j=0;j<nhist_[1];++j){
           avgGofr[i][j] += (gofr[i][j]-avgGofr[i][j])*factor;
           gofr[i][j] = avgGofr[i][j];
        }
     }
  }
  // Output of gofr
  if (doOutputGofr && (getStep()%outputStride==0)) outputGofr(gofr,"gofr.txt");
  // Construct integrand
  Matrix<double> integrand(nhist_[0],nhist_[1]);
  Matrix<double> logGofrx1sqr(nhist_[0],nhist_[1]);
  for(unsigned i=0;i<nhist_[0];++i){
     for(unsigned j=0;j<nhist_[1];++j){
        if (doReferenceGofr) {
           if (gofr[i][j]<1.e-10) {
              integrand[i][j] = (referenceGofr[i][j]+epsilon)*x1sqr[i];
           } else {
              logGofrx1sqr[i][j] = std::log(gofr[i][j]/(referenceGofr[i][j]+epsilon))*x1sqr[i];
              integrand[i][j] = gofr[i][j]*logGofrx1sqr[i][j]+(-gofr[i][j]+referenceGofr[i][j]+epsilon)*x1sqr[i];
           }
        } else {
           if (gofr[i][j]<1.e-10) {
              integrand[i][j] = x1sqr[i];
           } else {
              logGofrx1sqr[i][j] = std::log(gofr[i][j])*x1sqr[i];
              integrand[i][j] = gofr[i][j]*logGofrx1sqr[i][j]+(-gofr[i][j]+1)*x1sqr[i];
           }
        }
     }
  }
  vector<double> delta(2);
  delta[0]=deltar;
  delta[1]=deltaCosAngle;
  double TwoPiDensityVolAngles;
  if (densityReference>0) TwoPiDensityVolAngles=(2*pi/volumeOfAngles)*densityReference;
  else TwoPiDensityVolAngles=(2*pi/volumeOfAngles)*density;
  double pairEntropy=-TwoPiDensityVolAngles*integrate(integrand,delta);
  //std::cout << "Integrand and integration: " << float( clock () - begin_time ) << "\n";
  //begin_time = clock();
  // Derivatives
  vector<Vector> deriv(getNumberOfAtoms());
  Tensor virial;
  if (!doNotCalculateDerivatives() ) {
    if (doneigh) {
       for(unsigned int k=0;k<nl->getNumberOfLocalAtoms();k+=1) {
         unsigned index=nl->getIndexOfLocalAtom(k);
         // Center atom
         unsigned start1_atom=index+center_lista.size();
         unsigned end1_atom=index+2*center_lista.size();
         unsigned start2_atom=index+3*center_lista.size();
         unsigned end2_atom=index+4*center_lista.size();
         Matrix<Vector> integrandDerivatives(nhist_[0],nhist_[1]);
         Matrix<Vector> integrandDerivativesStart1(nhist_[0],nhist_[1]);
         Matrix<Vector> integrandDerivativesEnd1(nhist_[0],nhist_[1]);
         Matrix<Vector> integrandDerivativesStart2(nhist_[0],nhist_[1]);
         Matrix<Vector> integrandDerivativesEnd2(nhist_[0],nhist_[1]);
         for(unsigned i=0;i<nhist_[0];++i){
           for(unsigned j=0;j<nhist_[1];++j){
             if (gofr[i][j]>1.e-10) {
               integrandDerivatives[i][j] = gofrPrimeCenter[index*nhist1_nhist2_+i*nhist_[1]+j]*logGofrx1sqr[i][j];
               integrandDerivativesStart1[i][j] = gofrPrimeStart1[index*nhist1_nhist2_+i*nhist_[1]+j]*logGofrx1sqr[i][j];
               integrandDerivativesEnd1[i][j] = gofrPrimeEnd1[index*nhist1_nhist2_+i*nhist_[1]+j]*logGofrx1sqr[i][j];
               integrandDerivativesStart2[i][j] = gofrPrimeStart2[index*nhist1_nhist2_+i*nhist_[1]+j]*logGofrx1sqr[i][j];
               integrandDerivativesEnd2[i][j] = gofrPrimeEnd2[index*nhist1_nhist2_+i*nhist_[1]+j]*logGofrx1sqr[i][j];
             }
           }
         }
         deriv[index] = -TwoPiDensityVolAngles*integrate(integrandDerivatives,delta);
         deriv[start1_atom] = -TwoPiDensityVolAngles*integrate(integrandDerivativesStart1,delta);
         deriv[end1_atom] = -TwoPiDensityVolAngles*integrate(integrandDerivativesEnd1,delta);
         deriv[start2_atom] = -TwoPiDensityVolAngles*integrate(integrandDerivativesStart2,delta);
         deriv[end2_atom] = -TwoPiDensityVolAngles*integrate(integrandDerivativesEnd2,delta);
       }
    } else {
       for(unsigned int k=rank;k<center_lista.size();k+=stride) {
         // Center atom
         unsigned start1_atom=k+center_lista.size();
         unsigned end1_atom=k+2*center_lista.size();
         unsigned start2_atom=k+3*center_lista.size();
         unsigned end2_atom=k+4*center_lista.size();
         Matrix<Vector> integrandDerivatives(nhist_[0],nhist_[1]);
         Matrix<Vector> integrandDerivativesStart1(nhist_[0],nhist_[1]);
         Matrix<Vector> integrandDerivativesEnd1(nhist_[0],nhist_[1]);
         Matrix<Vector> integrandDerivativesStart2(nhist_[0],nhist_[1]);
         Matrix<Vector> integrandDerivativesEnd2(nhist_[0],nhist_[1]);
         for(unsigned i=0;i<nhist_[0];++i){
           for(unsigned j=0;j<nhist_[1];++j){
             if (gofr[i][j]>1.e-10) {
               integrandDerivatives[i][j] = gofrPrimeCenter[k*nhist1_nhist2_+i*nhist_[1]+j]*logGofrx1sqr[i][j];
               integrandDerivativesStart1[i][j] = gofrPrimeStart1[k*nhist1_nhist2_+i*nhist_[1]+j]*logGofrx1sqr[i][j];
               integrandDerivativesEnd1[i][j] = gofrPrimeEnd1[k*nhist1_nhist2_+i*nhist_[1]+j]*logGofrx1sqr[i][j];
               integrandDerivativesStart2[i][j] = gofrPrimeStart2[k*nhist1_nhist2_+i*nhist_[1]+j]*logGofrx1sqr[i][j];
               integrandDerivativesEnd2[i][j] = gofrPrimeEnd2[k*nhist1_nhist2_+i*nhist_[1]+j]*logGofrx1sqr[i][j];
             }
           }
         }
         deriv[k] = -TwoPiDensityVolAngles*integrate(integrandDerivatives,delta);
         deriv[start1_atom] = -TwoPiDensityVolAngles*integrate(integrandDerivativesStart1,delta);
         deriv[end1_atom] = -TwoPiDensityVolAngles*integrate(integrandDerivativesEnd1,delta);
         deriv[start2_atom] = -TwoPiDensityVolAngles*integrate(integrandDerivativesStart2,delta);
         deriv[end2_atom] = -TwoPiDensityVolAngles*integrate(integrandDerivativesEnd2,delta);
       }
    }
    if(!serial){
      comm.Sum(&deriv[0][0],3*getNumberOfAtoms());
    }
    // Virial of positions
    // Construct virial integrand
    Matrix<Tensor> integrandVirial(nhist_[0],nhist_[1]);
    for(unsigned i=0;i<nhist_[0];++i){
       for(unsigned j=0;j<nhist_[1];++j){
          if (gofr[i][j]>1.e-10) {
             integrandVirial[i][j] = gofrVirial[i][j]*logGofrx1sqr[i][j];
          }
      }
    }
    // Integrate virial
    virial = -TwoPiDensityVolAngles*integrate(integrandVirial,delta);
    // Virial of volume
    // Construct virial integrand
    Matrix<double> integrandVirialVolume(nhist_[0],nhist_[1]);
    for(unsigned i=0;i<nhist_[0];++i){
       for(unsigned j=0;j<nhist_[1];++j){
          if (densityReference>0) {
            integrandVirialVolume[i][j] = -gofr[i][j]*logGofrx1sqr[i][j];
          } else if (doReferenceGofr && densityReference<0) {
            integrandVirialVolume[i][j] = (-gofr[i][j]+referenceGofr[i][j]+epsilon)*x1sqr[i];
          } else {
            integrandVirialVolume[i][j] = (-gofr[i][j]+1)*x1sqr[i];
          }
       }
    }
    // Integrate virial
    virial += -TwoPiDensityVolAngles*integrate(integrandVirialVolume,delta)*Tensor::identity();
  }
  //std::cout << "Derivatives integration: " << float( clock () - begin_time ) << "\n";
  // Assign output quantities
  for(unsigned i=0;i<deriv.size();++i) setAtomsDerivatives(i,deriv[i]);
  setValue           (pairEntropy);
  setBoxDerivatives  (virial);
}

double PairOrientationalEntropyPerpendicular::kernel(vector<double> distance, double invNormKernel, vector<double>&der)const{
  // Gaussian function and derivative
  double result = invNormKernel*std::exp(-distance[0]*distance[0]/twoSigma1Sqr-distance[1]*distance[1]/twoSigma2Sqr) ;
  //double result = invTwoPiSigma1Sigma2*std::exp(-distance[0]*distance[0]/twoSigma1Sqr-distance[1]*distance[1]/twoSigma2Sqr) ;
  der[0] = -distance[0]*result/sigma1Sqr;
  der[1] = -distance[1]*result/sigma2Sqr;
  return result;
}

double PairOrientationalEntropyPerpendicular::integrate(Matrix<double> integrand, vector<double> delta)const{
  // Trapezoid rule
  double result = 0.;
  for(unsigned i=1;i<(nhist_[0]-1);++i){
     for(unsigned j=1;j<(nhist_[1]-1);++j){
        result += integrand[i][j];
     }
  }
  // Edges
  for(unsigned i=1;i<(nhist_[0]-1);++i){
     result += 0.5*integrand[i][0];
     result += 0.5*integrand[i][nhist_[1]-1];
  }
  for(unsigned j=1;j<(nhist_[1]-1);++j){
     result += 0.5*integrand[0][j];
     result += 0.5*integrand[nhist_[0]-1][j];
  }
  // Corners
  result += 0.25*integrand[0][0];
  result += 0.25*integrand[nhist_[0]-1][0];
  result += 0.25*integrand[0][nhist_[1]-1];
  result += 0.25*integrand[nhist_[0]-1][nhist_[1]-1];
  // Spacing
  result *= delta[0]*delta[1];
  return result;
}

Vector PairOrientationalEntropyPerpendicular::integrate(Matrix<Vector> integrand, vector<double> delta)const{
  // Trapezoid rule
  Vector result;
  for(unsigned i=1;i<(nhist_[0]-1);++i){
     for(unsigned j=1;j<(nhist_[1]-1);++j){
        result += integrand[i][j];
     }
  }
  // Edges
  for(unsigned i=1;i<(nhist_[0]-1);++i){
     result += 0.5*integrand[i][0];
     result += 0.5*integrand[i][nhist_[1]-1];
  }
  for(unsigned j=1;j<(nhist_[1]-1);++j){
     result += 0.5*integrand[0][j];
     result += 0.5*integrand[nhist_[0]-1][j];
  }
  // Corners
  result += 0.25*integrand[0][0];
  result += 0.25*integrand[nhist_[0]-1][0];
  result += 0.25*integrand[0][nhist_[1]-1];
  result += 0.25*integrand[nhist_[0]-1][nhist_[1]-1];
  // Spacing
  result *= delta[0]*delta[1];
  return result;
}

Tensor PairOrientationalEntropyPerpendicular::integrate(Matrix<Tensor> integrand, vector<double> delta)const{
  // Trapezoid rule
  Tensor result;
  for(unsigned i=1;i<(nhist_[0]-1);++i){
     for(unsigned j=1;j<(nhist_[1]-1);++j){
        result += integrand[i][j];
     }
  }
  // Edges
  for(unsigned i=1;i<(nhist_[0]-1);++i){
     result += 0.5*integrand[i][0];
     result += 0.5*integrand[i][nhist_[1]-1];
  }
  for(unsigned j=1;j<(nhist_[1]-1);++j){
     result += 0.5*integrand[0][j];
     result += 0.5*integrand[nhist_[0]-1][j];
  }
  // Corners
  result += 0.25*integrand[0][0];
  result += 0.25*integrand[nhist_[0]-1][0];
  result += 0.25*integrand[0][nhist_[1]-1];
  result += 0.25*integrand[nhist_[0]-1][nhist_[1]-1];
  // Spacing
  result *= delta[0]*delta[1];
  return result;
}

void PairOrientationalEntropyPerpendicular::outputGofr(Matrix<double> gofr, const char* fileName) {
  for(unsigned i=0;i<nhist_[0];++i){
     for(unsigned j=0;j<nhist_[1];++j){
        gofrOfile.printField("r",x1[i]).printField("theta",x2[j]).printField("gofr",gofr[i][j]).printField();
     }
     gofrOfile.printf("\n");
  }
  gofrOfile.printf("\n");
  gofrOfile.printf("\n");
}

}
}
src/tools/0000777000175000017500000000000013777445145012010 5ustar  maplemaplesrc/tools/NeighborListParallel.cpp0000777000175000017500000004245513777445145016577 0ustar  maplemaple/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   Copyright (c) 2011-2017 The plumed team
   (see the PEOPLE file at the root of the distribution for a list of names)

   See http://www.plumed.org for more information.

   This file is part of plumed, version 2.

   plumed is free software: you can redistribute it and/or modify
   it under the terms of the GNU Lesser General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   plumed is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public License
   along with plumed.  If not, see <http://www.gnu.org/licenses/>.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
#include "NeighborListParallel.h"
#include "Vector.h"
#include "Pbc.h"
#include "AtomNumber.h"
#include "Tools.h"
#include <vector>
#include <algorithm>
#include "Communicator.h"
#include "Log.h"

namespace PLMD {
using namespace std;

NeighborListParallel::NeighborListParallel(const vector<AtomNumber>& list0, const vector<AtomNumber>& list1,
                           const bool& do_pair, const bool& do_pbc, const Pbc& pbc, Communicator& cc, Log& log,
                           const double& distance, const bool& do_full_list, const int& stride, const double& skin): 
  do_pair_(do_pair), do_pbc_(do_pbc), pbc_(&pbc),
  distance_(distance), stride_(stride), mycomm(cc), mylog(log),
  skin_(skin), do_full_list_(do_full_list)
{
// store full list of atoms needed
  fullatomlist_=list0;
  fullatomlist_.insert(fullatomlist_.end(),list1.begin(),list1.end());
  nlist0_=list0.size();
  nlist1_=list1.size();
  twolists_=true;
  if(!do_pair) {
    nallpairs_=nlist0_*nlist1_;
  } else {
    plumed_assert(nlist0_==nlist1_);
    nallpairs_=nlist0_;
  }
  lastupdate_=0;
  positions_old_.resize(fullatomlist_.size());
  dangerousBuilds_=0;
  firsttime_=true;
  numberOfBuilds_=0;
  avgTotalNeighbors_=0.;
  maxLoadImbalance_=2.;
  avgLoadImbalance_=0.;
  // Setup mpi
  mpi_rank=mycomm.Get_rank();
  mpi_stride=mycomm.Get_size();
}

NeighborListParallel::NeighborListParallel(const vector<AtomNumber>& list0, const bool& do_pbc,
                           const Pbc& pbc, Communicator& cc, Log& log, const double& distance,
                           const bool& do_full_list, const int& stride, const double& skin):
  do_pbc_(do_pbc), pbc_(&pbc),
  distance_(distance), stride_(stride), mycomm(cc), mylog(log),
  skin_(skin) , do_full_list_(do_full_list)
{
  fullatomlist_=list0;
  nlist0_=list0.size();
  twolists_=false;
  nallpairs_=nlist0_*(nlist0_-1)/2;
  lastupdate_=0;
  positions_old_.resize(fullatomlist_.size());
  dangerousBuilds_=0;
  firsttime_=true;
  numberOfBuilds_=0;
  avgTotalNeighbors_=0.;
  maxLoadImbalance_=2.;
  avgLoadImbalance_=0.;
  // Setup mpi
  mpi_rank=mycomm.Get_rank();
  mpi_stride=mycomm.Get_size();
}

vector<AtomNumber>& NeighborListParallel::getFullAtomList() {
  return fullatomlist_;
}

bool NeighborListParallel::isListStillGood(const vector<Vector>& positions) {
  bool flag=true;
  plumed_assert(positions.size()==fullatomlist_.size());
  for(unsigned int i=0;i<fullatomlist_.size();i++) {
    Vector distance;
    if(do_pbc_) {
       distance=pbc_->distance(positions[i],positions_old_[i]);
    } else {
       distance=delta(positions[i],positions_old_[i]);
    }
    if (modulo(distance)>skin_) {
       flag=false;
       break;
    }
  }
  return flag;
}

void NeighborListParallel::printStats() {
  mylog.printf("Neighbor list statistics\n");
  mylog.printf("Total # of neighbors = %f \n", avgTotalNeighbors_);
  mylog.printf("Ave neighs/atom = %f \n", avgTotalNeighbors_ /(double) nlist0_);
  mylog.printf("Neighbor list builds = %d \n",numberOfBuilds_);
  mylog.printf("Dangerous builds = %d \n",dangerousBuilds_);
  mylog.printf("Average load imbalance (min/max) = %f \n",avgLoadImbalance_);
  mylog.printf("Maximum load imbalance (min/max) = %f \n",maxLoadImbalance_);
  if (do_linked_list_) {
     mylog.printf("Number of bins in linked list = %d %d %d \n", nbinx, nbiny, nbinz);
  }
}

void NeighborListParallel::update(const vector<Vector>& positions) {
  // clear previous list
  neighbors_.clear();
  local_atoms_.clear();
  // check if positions array has the correct length
  plumed_assert(positions.size()==fullatomlist_.size());
  // Prepare linked lists
  prepareLinkedList();
  // Decide whether to do linked lists or the N^2 calculation
  do_linked_list_=true;
  if ((2*sx+1) >= nbinx || (2*sy+1) >= nbiny || (2*sz+1) >= nbinz) do_linked_list_=false;
  if (do_linked_list_) {
     if (!do_full_list_) updateHalfListWithLinkedList(positions);
     else updateFullListWithLinkedList(positions);
  } else {
     if (!do_full_list_) updateHalfList(positions);
     else updateFullList(positions);
  }
  gatherStats(positions);
  // Store positions for checking
  for(unsigned int i=0;i<fullatomlist_.size();i++) {
     positions_old_[i]=positions[i];
  }
}

void NeighborListParallel::updateFullListWithLinkedList(const vector<Vector>& positions) {
  const double d2=distance_*distance_;
  // Set bin head of chain to -1.0
  binhead = std::vector<int>(nbinx*nbiny*nbinz,-1.0);
  if (!twolists_) {
    neighbors_.resize(nlist0_);
    // Construct linked list and assign head of chain
    bins.resize(nlist0_);
    for(unsigned int i=0;i<nlist0_;i+=1) {
       unsigned ibin = coord2bin(positions[i]);
       bins[i] = binhead[ibin];
       binhead[ibin] = i;
    }
    // Calculate
    for(unsigned int i=mpi_rank;i<nlist0_;i+=mpi_stride) {
       local_atoms_.push_back(i);
       Vector position_i=positions[i];
       unsigned atombinx, atombiny, atombinz, atombin;
       atombin = coord2bin(positions[i],atombinx, atombiny, atombinz);
       for(unsigned k=0; k < nstencil; k++) {
          // Loop over atoms in the k-th neighboring cell
          unsigned kbin = neighborCell(k,atombinx, atombiny, atombinz) ;
          for (int j = binhead[kbin]; j >= 0; j = bins[j]) {
             double value=modulo2(distance(position_i,positions[j]));
             if(value<=d2) neighbors_[i].push_back(j);
          }
       }
    }
  } else if (twolists_ && !do_pair_) {
    neighbors_.resize(nlist0_+nlist1_);
    // Construct linked list and assign head of chain
    bins.resize(nlist1_);
    for(unsigned int i=0;i<nlist1_;i++) {
       unsigned ibin = coord2bin(positions[i+nlist0_]);
       bins[i] = binhead[ibin];
       binhead[ibin] = i;
    }
    // Calculate
    for(unsigned int i=mpi_rank;i<nlist0_;i+=mpi_stride) {
       local_atoms_.push_back(i);
       Vector position_i=positions[i];
       unsigned atombinx, atombiny, atombinz, atombin;
       atombin = coord2bin(positions[i],atombinx, atombiny, atombinz);
       for(unsigned k=0; k < nstencil; k++) {
          // Loop over atoms in the k-th neighboring cell
          unsigned kbin = neighborCell(k,atombinx, atombiny, atombinz) ;
          for (int j = binhead[kbin]; j >= 0; j = bins[j]) {
             double value=modulo2(distance(position_i,positions[j+nlist0_]));
             if(value<=d2) {
                neighbors_[i].push_back(j+nlist0_);
                neighbors_[j+nlist0_].push_back(i);
             }
          }
       }
    }
  }
}

void NeighborListParallel::updateHalfListWithLinkedList(const vector<Vector>& positions) {
  const double d2=distance_*distance_;
  neighbors_.resize(nlist0_);
  // Set bin head of chain to -1.0
  binhead = std::vector<int>(nbinx*nbiny*nbinz,-1.0);
  if (!twolists_) {
    // Construct linked list and assign head of chain
    bins.resize(nlist0_);
    for(unsigned int i=0;i<nlist0_;i+=1) {
       unsigned ibin = coord2bin(positions[i]);
       bins[i] = binhead[ibin];
       binhead[ibin] = i;
    }
    // Calculate
    for(unsigned int i=mpi_rank;i<nlist0_;i+=mpi_stride) {
       local_atoms_.push_back(i);
       Vector position_i=positions[i];
       unsigned atombinx, atombiny, atombinz, atombin;
       atombin = coord2bin(positions[i],atombinx, atombiny, atombinz);
       for(unsigned k=0; k < nstencil; k++) {
          // Loop over atoms in the k-th neighboring cell
          unsigned kbin = neighborCell(k,atombinx, atombiny, atombinz) ;
          for (int j = binhead[kbin]; j >= 0; j = bins[j]) {
             if (j>=i) continue;
             double value=modulo2(distance(position_i,positions[j]));
             if(value<=d2) neighbors_[i].push_back(j);
          }
       }
    }
  } else if (twolists_ && !do_pair_) {
    // Construct linked list and assign head of chain
    bins.resize(nlist1_);
    for(unsigned int i=0;i<nlist1_;i++) {
       unsigned ibin = coord2bin(positions[i+nlist0_]);
       bins[i] = binhead[ibin];
       binhead[ibin] = i;
    }
    // Calculate
    for(unsigned int i=mpi_rank;i<nlist0_;i+=mpi_stride) {
       local_atoms_.push_back(i);
       Vector position_i=positions[i];
       unsigned atombinx, atombiny, atombinz, atombin;
       atombin = coord2bin(positions[i],atombinx, atombiny, atombinz);
       for(unsigned k=0; k < nstencil; k++) {
          // Loop over atoms in the k-th neighboring cell
          unsigned kbin = neighborCell(k,atombinx, atombiny, atombinz) ;
          for (int j = binhead[kbin]; j >= 0; j = bins[j]) {
             double value=modulo2(distance(position_i,positions[j+nlist0_]));
             if(value<=d2) {
                neighbors_[i].push_back(j+nlist0_);
             }
          }
       }
    }
  }
}


void NeighborListParallel::updateFullList(const vector<Vector>& positions) {
  const double d2=distance_*distance_;
  if (!twolists_) {
    neighbors_.resize(nlist0_);
    for(unsigned int i=mpi_rank;i<nlist0_;i+=mpi_stride) {
       local_atoms_.push_back(i);
       Vector position_i=positions[i];
       for(unsigned int j=0;j<nlist0_;j+=1) {
          double value=modulo2(distance(position_i,positions[j]));
          if(value<=d2) neighbors_[i].push_back(j);
       }
    }
  } else if(twolists_ && do_pair_) {
    neighbors_.resize(nlist0_+nlist1_);
    for(unsigned int i=mpi_rank;i<nlist0_;i+=mpi_stride) {
       local_atoms_.push_back(i);
       double value=modulo2(distance(positions[i],positions[nlist0_+i]));
       if(value<=d2) {
          neighbors_[i].push_back(nlist0_+i);
          neighbors_[nlist0_].push_back(i);
       }
    }
  } else if (twolists_ && !do_pair_) {
    neighbors_.resize(nlist0_+nlist1_);
    for(unsigned int i=mpi_rank;i<nlist0_;i+=mpi_stride) {
       local_atoms_.push_back(i);
       Vector position_i=positions[i];
       for(unsigned int j=0;j<nlist1_;j+=1) {
          double value=modulo2(distance(position_i,positions[nlist0_+j]));
          if(value<=d2) {
             neighbors_[i].push_back(nlist0_+j);
             neighbors_[nlist0_+j].push_back(i);
          }
       }
    }
  }
}

void NeighborListParallel::updateHalfList(const vector<Vector>& positions) {
  const double d2=distance_*distance_;
  neighbors_.resize(nlist0_);
  if (!twolists_) {
    for(unsigned int i=mpi_rank;i<nlist0_;i+=mpi_stride) {
       local_atoms_.push_back(i);
       Vector position_i=positions[i];
       for(unsigned int j=i+1;j<nlist0_;j+=1) {
          double value=modulo2(distance(position_i,positions[j]));
          if(value<=d2) neighbors_[i].push_back(j);
       }
    }
  } else if(twolists_ && do_pair_) {
    for(unsigned int i=mpi_rank;i<nlist0_;i+=mpi_stride) {
       local_atoms_.push_back(i);
       double value=modulo2(distance(positions[i],positions[nlist0_+i]));
       if(value<=d2) neighbors_[i].push_back(nlist0_+i);
    }
  } else if (twolists_ && !do_pair_) {
    for(unsigned int i=mpi_rank;i<nlist0_;i+=mpi_stride) {
       local_atoms_.push_back(i);
       Vector position_i=positions[i];
       for(unsigned int j=0;j<nlist1_;j++) {
          double value=modulo2(distance(position_i,positions[nlist0_+j]));
          if(value<=d2) {
             neighbors_[i].push_back(nlist0_+j);
          }
       }
    }
  }
}

void NeighborListParallel::gatherStats(const vector<Vector>& positions) {
  // Check if rebuilt was dangerous
  if (!firsttime_ && !isListStillGood(positions)) {
     dangerousBuilds_++;
  }
  firsttime_=false;
  numberOfBuilds_++;
  unsigned neighNum=0;
  for(unsigned int i=0;i<nlist0_;i++) {
     neighNum += neighbors_[i].size();
  }
  unsigned allNeighNum=0;
  std::vector<unsigned> neighbors_ranks_(mycomm.Get_size());
  mycomm.Allgather(&neighNum,1,&neighbors_ranks_[0],1);
  for(unsigned int i=0;i<mycomm.Get_size();i+=1) allNeighNum+=neighbors_ranks_[i];
  auto min_element_ = *std::min_element(neighbors_ranks_.begin(), neighbors_ranks_.end());
  auto max_element_ = *std::max_element(neighbors_ranks_.begin(), neighbors_ranks_.end());
  double loadImbalance=min_element_ / (double) max_element_;
  if (maxLoadImbalance_>loadImbalance) maxLoadImbalance_=loadImbalance;
  avgLoadImbalance_ += (loadImbalance-avgLoadImbalance_)/numberOfBuilds_;
  avgTotalNeighbors_ += (allNeighNum-avgTotalNeighbors_)/numberOfBuilds_;
}

unsigned NeighborListParallel::getNumberOfLocalAtoms() const {
  return local_atoms_.size();
}

unsigned NeighborListParallel::getIndexOfLocalAtom(unsigned i) const {
  return local_atoms_[i];
}

int NeighborListParallel::getStride() const {
  return stride_;
}

unsigned NeighborListParallel::getLastUpdate() const {
  return lastupdate_;
}

void NeighborListParallel::setLastUpdate(unsigned step) {
  lastupdate_=step;
}

// This function is obsolete and should be changed
unsigned NeighborListParallel::size() const {
  return neighbors_.size();
}

// This function is obsolete and should be changed
pair<unsigned,unsigned> NeighborListParallel::getClosePair(unsigned i) const {
  return pair<unsigned,unsigned>(i,i);
}

vector<unsigned> NeighborListParallel::getNeighbors(unsigned index) {
  return neighbors_[index];
}

Vector NeighborListParallel::distance(const Vector& position1, const Vector& position2) {
  Vector distance;
  if(do_pbc_) {
    distance=pbc_->distance(position1,position2);
  } else {
    distance=delta(position1,position2);
  }
  return distance;
}

// Linked lists stuff

void NeighborListParallel::prepareLinkedList() {
  // Determine optimal number of cells in each direction
  double binsize_optimal = 0.5*distance_;
  double binsizeinv = 1.0/binsize_optimal;
  Tensor bbox=pbc_->getBox();
  nbinx = static_cast<int> (bbox[0][0]*binsizeinv);
  nbiny = static_cast<int> (bbox[1][1]*binsizeinv);
  nbinz = static_cast<int> (bbox[2][2]*binsizeinv);
  if (nbinx == 0) nbinx = 1;
  if (nbiny == 0) nbiny = 1;
  if (nbinz == 0) nbinz = 1;
  // Determine cell sizes
  binsizex = 1.0 / nbinx;
  binsizey = 1.0 / nbiny;
  binsizez = 1.0 / nbinz;
  bininvx = 1.0 / binsizex;
  bininvy = 1.0 / binsizey;
  bininvz = 1.0 / binsizez;
  // sx,sy,sz = max range of stencil in each dim
  Vector scaled_distance_=pbc_->realToScaled(Vector(distance_,distance_,distance_));
  sx = static_cast<int> (scaled_distance_[0]*bininvx);
  if (sx*binsizex < scaled_distance_[0]) sx++;
  sy = static_cast<int> (scaled_distance_[1]*bininvy);
  if (sy*binsizey < scaled_distance_[1]) sy++;
  sz = static_cast<int> (scaled_distance_[2]*bininvz);
  if (sz*binsizez < scaled_distance_[2]) sz++;
  // Create stencil
  nstencil = (2*sx+1)*(2*sy+1)*(2*sz+1);
  stencilx.resize(nstencil);
  stencily.resize(nstencil);
  stencilz.resize(nstencil);
  unsigned k=0;
  for(int ix=-sx;ix<=sx;ix++) {
     for(int iy=-sy;iy<=sy;iy++) {
        for(int iz=-sz;iz<=sz;iz++) {
           stencilx[k]=ix;
           stencily[k]=iy;
           stencilz[k]=iz;
           k++;
        }
     }
  }
   // clear previous list
  bins.clear();
  binhead.clear();
}

unsigned NeighborListParallel::neighborCell(const unsigned& k, const unsigned& atombinx, const unsigned& atombiny, const unsigned& atombinz) {
  int ibinx = atombinx+stencilx[k];
  if (ibinx<0) ibinx += nbinx; 
  if (ibinx>=nbinx) ibinx -= nbinx;
  int ibiny = atombiny+stencily[k];
  if (ibiny<0) ibiny += nbiny; 
  if (ibiny>=nbiny) ibiny -= nbiny;
  int ibinz = atombinz+stencilz[k];
  if (ibinz<0) ibinz += nbinz; 
  if (ibinz>=nbinz) ibinz -= nbinz;
  unsigned neighbor = ibinx + ibiny*nbinx + ibinz*nbinx*nbiny;
  return neighbor; 
}

unsigned NeighborListParallel::coord2bin(const Vector& position) {
  Vector pbc_position=pbc_->distance(Vector(0.0,0.0,0.0),position);
  Vector scaled_position=pbc_->realToScaled(pbc_position);
  if (scaled_position[0]<0.) scaled_position[0] += 1;
  if (scaled_position[1]<0.) scaled_position[1] += 1;
  if (scaled_position[2]<0.) scaled_position[2] += 1;
  unsigned ibinx, ibiny, ibinz, ibin;
  ibinx = static_cast<int> (scaled_position[0]*bininvx);
  ibiny = static_cast<int> (scaled_position[1]*bininvy);
  ibinz = static_cast<int> (scaled_position[2]*bininvz);
  ibin = ibinx + ibiny*nbinx + ibinz*nbinx*nbiny;
  return ibin;
}

unsigned NeighborListParallel::coord2bin(const Vector& position, unsigned& ibinx, unsigned& ibiny, unsigned& ibinz) {
  Vector pbc_position=pbc_->distance(Vector(0.0,0.0,0.0),position);
  Vector scaled_position=pbc_->realToScaled(pbc_position);
  if (scaled_position[0]<0.) scaled_position[0] += 1;
  if (scaled_position[1]<0.) scaled_position[1] += 1;
  if (scaled_position[2]<0.) scaled_position[2] += 1;
  unsigned ibin;
  ibinx = static_cast<int> (scaled_position[0]*bininvx);
  ibiny = static_cast<int> (scaled_position[1]*bininvy);
  ibinz = static_cast<int> (scaled_position[2]*bininvz);
  ibin = ibinx + ibiny*nbinx + ibinz*nbinx*nbiny;
  return ibin;
}

}
src/tools/NeighborListParallel.h0000777000175000017500000001430213777445145016232 0ustar  maplemaple/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   Copyright (c) 2011-2017 The plumed team
   (see the PEOPLE file at the root of the distribution for a list of names)

   See http://www.plumed.org for more information.

   This file is part of plumed, version 2.

   plumed is free software: you can redistribute it and/or modify
   it under the terms of the GNU Lesser General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   plumed is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public License
   along with plumed.  If not, see <http://www.gnu.org/licenses/>.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
#ifndef __PLUMED_tools_NeighborListParallel_h
#define __PLUMED_tools_NeighborListParallel_h

#include "Vector.h"
#include "AtomNumber.h"
#include "Communicator.h"
#include "Log.h"

#include <vector>

namespace PLMD {

class Pbc;

/// \ingroup TOOLBOX
/// A class that implements neighbor lists from two lists or a single list of atoms
class NeighborListParallel
{
  bool do_pair_,do_pbc_,twolists_,firsttime_;
/// Choose between half and full list
  bool do_full_list_;
  const PLMD::Pbc* pbc_;
/// Full list of atoms involved
  std::vector<PLMD::AtomNumber> fullatomlist_,requestlist_;
/// Positions during the building of the NL
/// They are used for checking if the next build is dangerous
  std::vector<PLMD::Vector> positions_old_;
/// Neighbor list
  std::vector<std::vector<unsigned>> neighbors_;
  //std::vector<std::pair<unsigned,unsigned> > neighbors_;
/// List of the "local" atoms each thread has
  std::vector<unsigned> local_atoms_;
  double distance_, skin_;
  int stride_;
  unsigned nlist0_,nlist1_,nallpairs_,lastupdate_;
  unsigned dangerousBuilds_, numberOfBuilds_;
  double maxLoadImbalance_,avgLoadImbalance_, avgTotalNeighbors_;
/// Return the pair of indexes in the positions array
/// of the two atoms forming the i-th pair among all possible pairs
  //std::pair<unsigned,unsigned> getIndexPair(unsigned i);
/// Communicator
  Communicator& mycomm;
/// Log
  Log& mylog;
/// MPI stuff
  unsigned mpi_rank, mpi_stride;
/// Linked list stuff
  double binsizex, binsizey, binsizez, bininvx, bininvy, bininvz ;
  bool do_linked_list_;
/// Number of bins in x,y,z
  int nbinx, nbiny, nbinz;
/// Head of chain for each bin
  std::vector<int> binhead;
/// Linked list for each bin
  std::vector<unsigned> bins;
/// sx,sy,sz = max range of stencil in each dim
  int sx,sy,sz;
/// Number of stencils
  unsigned nstencil;
/// Stencil indices
  std::vector<unsigned> stencilx, stencily, stencilz;
public:
  NeighborListParallel(const std::vector<PLMD::AtomNumber>& list0,
               const std::vector<PLMD::AtomNumber>& list1,
               const bool& do_pair, const bool& do_pbc, const PLMD::Pbc& pbc, Communicator& cc,
               Log& log, const double& distance=1.0e+30,  const bool& do_full_list=false, const int& stride=0, const double& skin=0.1);
  NeighborListParallel(const std::vector<PLMD::AtomNumber>& list0, const bool& do_pbc,
               const PLMD::Pbc& pbc, Communicator& cc, Log& log, const double& distance=1.0e+30,
               const bool& do_full_list=false, const int& stride=0, const double& skin=0.1);
/// Return the list of all atoms. These are needed to rebuild the neighbor list.
  std::vector<PLMD::AtomNumber>& getFullAtomList();
/// Check if the nieghbor list must be rebuilt
  bool isListStillGood(const std::vector<Vector>& positions);
/// Update the indexes in the neighbor list to match the
/// ordering in the new positions array
/// and return the new list of atoms that must be requested to the main code
//  std::vector<PLMD::AtomNumber>& getReducedAtomList();
/// Update the neighbor list and prepare the new
/// list of atoms that will be requested to the main code
  void update(const std::vector<PLMD::Vector>& positions);
/// Construct a half neighbor list, containing only i,j and not j,i
  void updateHalfList(const std::vector<Vector>& positions);
/// Construct a full neighbor list, containing both i,j and j,i
  void updateFullList(const std::vector<Vector>& positions);
/// Construct a full neighbor list, containing both i,j and j,i ; Linked lists are used
  void updateFullListWithLinkedList(const std::vector<Vector>& positions);
/// Construct a half neighbor list, containing only i,j and not j,i ; Linked lists are used
  void updateHalfListWithLinkedList(const std::vector<Vector>& positions);
/// Get the update stride of the neighbor list
  int getStride() const;
/// Get the last step in which the neighbor list was updated
  unsigned getLastUpdate() const;
/// Set the step of the last update
  void setLastUpdate(unsigned step);
/// Get the size of the neighbor list - Obsolete
  unsigned size() const;
/// Get the i-th pair of the neighbor list - Obsolete
  std::pair<unsigned,unsigned> getClosePair(unsigned i) const;
/// Get the list of neighbors of the i-th atom
  std::vector<unsigned> getNeighbors(unsigned i);
  ~NeighborListParallel() {}
/// Print statistics of neighbor list
  void printStats();
/// Gather statistics of neighbor list
  void gatherStats(const std::vector<PLMD::Vector>& positions);
/// Get the local number of atoms (the ones each thread is handling)
  unsigned getNumberOfLocalAtoms() const;
/// Get the index if the i-th local atom
  unsigned getIndexOfLocalAtom(unsigned i) const;
/// Prepare linked lists
  void prepareLinkedList();
/// Coordinate to bin
  unsigned coord2bin(const Vector& position);
/// Coordinate to bin, get also position in x,y,z
  unsigned coord2bin(const Vector& position, unsigned& ibinx, unsigned& ibiny, unsigned& ibinz);
/// Find the k-th neighboring cell of cell atombinx,atombiny,atombinz
  unsigned neighborCell(const unsigned& k, const unsigned& atombinx, const unsigned& atombiny, const unsigned& atombinz);
/// Calculate the distance with or without pbc, as defined with the do_pbc_ flag
  Vector distance(const Vector& position1, const Vector& position2);
};

}

#endif
